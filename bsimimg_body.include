// ********************************************************
// **** BSIM-IMG 102.7.0beta  ****/
// *  BSIM Independent Multi-Gate Model (Verilog-A)
// *  four terminal device (d, fg, s, bg)
// ********************************************************
//
// ********************************************************
// * Copyright 2015 Regents of the University of California. 
// * All rights reserved.
// *
// * Project Director: Prof. Chenming Hu.
// * Authors: Chung-Hsun Lin, Mohan Dunga, Darsen Lu, 
// *          Sriramkumar V., Shijing Yao, 
// *          Srivatsava Jandhyala, Navid Paydavosi,
// *          Yogesh Singh Chauhan, Sourabh Khandelwal, 
// *          Pragya Kushwaha, Juan Pablo Duarte,
// *          Ali Niknejad, Chenming Hu
// ********************************************************

// ********************************************************
// ********************************************************
// *   NONDISCLOSURE STATEMENT
// Software is distributed as is, completely without warranty or service
// support. The University of California and its employees are not liable
// for the condition or performance of the software.
// The University of California owns the copyright and grants users a perpetual,
// irrevocable, worldwide, non-exclusive, royalty-free license with 
// respect to the software as set forth below.
// The University of California hereby disclaims all implied warranties.
// The University of California grants the users the right to modify, copy,
// and redistribute the software and documentation, both within the user's
// organization and externally, subject to the following restrictions
// 1. The users agree not to charge for the University of California code
// itself but may charge for additions, extensions, or support.
// 2. In any product based on the software, the users agree to acknowledge
// the University of California that developed the software. This
// acknowledgment shall appear in the product documentation.
// 3. The users agree to obey all U.S. Government restrictions governing
// redistribution or export of the software.
// 4. The users agree to reproduce any copyright notice which appears on
// the software on any copy or modification of such made available
// to others
// Agreed to on __April, 2015_________________
// By: ___University of California, Berkeley____ 
//     ___Chenming Hu_____________________ 
//     ___Professor in Graduate School _______
// ********************************************************
// ********************************************************

// Clamped exponential function
    analog function real lexp;
        input x;
        real x;

     begin
            if(x > `EXPL_THRESHOLD) begin
                lexp = `MAX_EXPL * (1.0+(x)-`EXPL_THRESHOLD);
            end else if(x < -`EXPL_THRESHOLD) begin
                lexp = `MIN_EXPL;
            end else begin
             lexp = exp(x);
            end
            end
    endfunction


// Clamped log function
    analog function real lln;
        input x;
        real x;

        begin
            lln = ln(max(x , `N_MINLOG));
        end
    endfunction

// Hyperbolic smoothing function
    analog function real hypsmooth;
        input x , c;
        real x , c;

        begin
            hypsmooth = 0.5 * (x + sqrt(x*x + 4*c*c));
        end
    endfunction

// Hyperbolic smooth max function
    analog function real hypmax;
        input   x , xmin, c;
        real x , xmin, c;

        begin
            hypmax  =  xmin + 0.5 * (x-xmin-c + sqrt((x-xmin-c)*(x-xmin-c)-4*xmin*c));
        end
    endfunction

//cot
    analog function real cot;
        input x;
        real x;

        begin
            cot = 1/tan(x);
        end
    endfunction
    
//coth
    analog function real coth;
        input x;
        real x;

        begin
            coth = 1/tanh(x);
        end
    endfunction  
    
//connectingfx
    analog function real connectingfx;
        input a, b, c;
        real a, b, c;

        begin
            connectingfx = a+b-0.5*(a+b-sqrt((a-b)*(a-b)+c));
        end
    endfunction        

//connectingfx2
    analog function real connectingfx2;
        input a, b, c;
        real a, b, c;

        begin
            if (a>0) begin
                connectingfx2 = 1.0/pow(pow(1.0/a,c)+pow(1.0/b,c),1.0/c);
            end else begin
                connectingfx2 = a;            
            end
            //connectingfx2 = //0.5*(a+b-sqrt((a-b)*(a-b)+c));
        end
    endfunction   

    analog function real connectingfx3;
        input a, b, c;
        real a, b, c;

        begin
            connectingfx3 = 0.5*(a+b-sqrt((a-b)*(a-b)+c));
        end
    endfunction  

// Node definitions
`ifdef __RDSMOD__
    `define IntrinsicDrain  di
        `define IntrinsicSource si
`else
        `define IntrinsicDrain  d
        `define IntrinsicSource s
`endif


`ifdef __RGATEMOD__
        `define IntrinsicGate gi
        `define GateEdgeNode  fg
`else
        `define  IntrinsicGate fg
    `define GateEdgeNode   fg
`endif


// *************************
//   Instance Parameters
// *************************
/* Note: Some instance parameters are also model parameters.  */
/*       Please refer to the technical note for details.      */
`IPRco( L              ,30n            ,"m"           ,1n          ,inf         ,"Designed Gate Length" ) 
`IPRco( W              ,1u             ,"m"           ,1n          ,inf         ,"Designed Gate Width" ) 
`IPIco( NF             ,1              ,""            ,1           ,inf         ,"Number of fingers" ) 
`IPRcz( AS             ,0.0            ,"m^2"                                   ,"Source area" ) 
`IPRcz( AD             ,0.0            ,"m^2"                                   ,"Drain area" ) 
`IPRcz( PS             ,0.0            ,"m"                                     ,"Source perimeter" ) 
`IPRcz( PD             ,0.0            ,"m"                                     ,"Drain perimeter" ) 
`IPRcz( NRS            ,0.0            ,""                                      ,"Number of source diffusion squares" ) 
`IPRcz( NRD            ,0.0            ,""                                      ,"Number of drain diffusion squares" ) 

//Variability Handles
`IPRnb( XL             ,0              ,"m"                                     ,"L offset for channel length due to mask/etch effect" ) 
`IPRnb( DTEMP          ,0              ,"Celsius"                               ,"Variability in Device Temperature" )
`IPRnb( DELVTRAND      ,0              ,"V"                                     ,"Variability in Vth" ) 
`IPRoz( U0MULT         ,1              ,""                                      ,"Variability in carrier mobility" ) 

// *************************
//   Model Parameters
// *************************
`MPIty( TYPE           ,`ntype         ,""                                      ,"NMOS=1, PMOS=-1" ) 
`MPIty( WELLTYPE       ,-TYPE          ,""                                      ,"Well (substrate) type" ) 
`MPIcc( CHARGEMOD      ,0              ,""            ,0           ,1           ,"0: Default inversion charge density model as in 102.0 version, 1: Accurate inversion charge density model as in 101.0 version" ) 
`MPIcc( RDSMOD         ,0              ,""            ,0           ,1           ,"0: Internal s/d resistance model, 1: External s/d resistance model" ) 
`MPIcc( GIDLMOD        ,0              ,""            ,0           ,1           ,"0: Turn off GIDL/GISL current, 1: Turn on GIDL/GISL current" ) 
`MPIcc( IGCMOD         ,1              ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd, 1: Turn on Igc, Igs and Igd" ) 
`MPIcc( IGBMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igb" ) 
`MPIcc( SHMOD          ,0              ,""            ,0           ,1           ,"0: No self-heating" ) 
`MPIcc( RGATEMOD       ,0              ,""            ,0           ,1           ,"Gate resistance model selector" ) 
`MPIcc( NFMOD          ,0              ,""            ,0           ,1           ,"0: W taken as total width like BSIM4, 1: W taken as single finger width  " ) 
`MPRnb( XW             ,0.0            ,"m"                                     ,"W offset for channel width due to mask/etch effect" ) 
`MPRnb( LINT           ,0.0            ,"m"                                     ,"delta L for IV" ) 
`MPRnb( LL             ,0.0            ,"m^(1+LLN)"                             ,"" ) 
`MPRnb( LW             ,0.0            ,"m^(1+LWN)"                             ,"" ) 
`MPRnb( LWL            ,0.0            ,"m^(LWN+LLN+1)"                         ,"" ) 
`MPRnb( LLN            ,1.0            ,""                                      ,"" ) 
`MPRnb( LWN            ,1.0            ,""                                      ,"" ) 
`MPRnb( WINT           ,0.0            ,"m"                                     ,"delta W for IV" ) 
`MPRnb( WL             ,0.0            ,"m^(1+WLN)"                             ,"" ) 
`MPRnb( WW             ,0.0            ,"m^(1+WWN)"                             ,"" ) 
`MPRnb( WWL            ,0.0            ,"m^(WLN+WWN+1)"                         ,"" ) 
`MPRnb( WLN            ,1.0            ,""                                      ,"" ) 
`MPRnb( WWN            ,1.0            ,""                                      ,"" ) 
`MPRnb( DLC            ,0.0            ,"m"                                     ,"delta L for CV" ) 
`MPRnb( LLC            ,0.0            ,"m"                                     ,"" ) 
`MPRnb( LWC            ,0.0            ,"m"                                     ,"" ) 
`MPRnb( LWLC           ,0.0            ,"m"                                     ,"" ) 
`MPRnb( DWC            ,0.0            ,"m"                                     ,"delta W for CV" ) 
`MPRnb( WLC            ,0.0            ,"m"                                     ,"" ) 
`MPRnb( WWC            ,0.0            ,"m"                                     ,"" ) 
`MPRnb( WWLC           ,0.0            ,"m"                                     ,"" ) 

`MPRco( EOT1           ,1.0n           ,"m"           ,0.1n        ,inf         ,"Equivalent front gate dielectric thickness relative to SiO2" ) 
`MPRco( EOT2           ,10n            ,"m"           ,0.1n        ,inf         ,"Equivalent back  gate dielectric thickness relative to SiO2" ) 
`MPRco( EOT1P          ,EOT1           ,"m"           ,0.1n        ,inf         ,"Equivalent physical front gate dielectric thickness relative to SiO2" ) 
`MPRnb( DTOX1          ,0.0            ,"m"                                     ,"Difference between effective dielectric thickness and physical thickness" ) 
`MPRco( TSI            ,8.0n           ,"m"           ,1n          ,inf         ,"Body thickness" ) 
`MPRcc( NBODY          ,1e22           ,"m^-3"        ,1e18        ,5e24        ,"channel (body) doping" ) 
`MPRcc( NSD            ,2e26           ,"m^-3"        ,2e25        ,1e27        ,"Source/drain active doping concentration" ) 
`MPRnb( NBG            ,5.0e23         ,"m^-3"                                  ,"Well/substrate (or also called back-gate) doping, zero for metal" ) 
`MPRcz( EASUB          ,4.05           ,"eV"                                    ,"Electron affinity of well/substrate" ) 
`MPRoz( NI0SUB         ,1.1e16         ,"m^-3"                                  ,"Intrinsic carrier constant at 300.15K" ) 
`MPRnb( BG0SUB         ,1.12           ,"eV"                                    ,"Band gap of well/substrate at 300.15K" ) 
`MPRoz( NC0SUB         ,2.86e25        ,""                                      ,"Conduction band density of states" ) 
`MPRnb( PHIG1          ,4.61           ,"eV"                                    ,"Front Gate Workfunction" ) 
`MPRnb( PHIG2          ,((WELLTYPE == `ptype) ? (EASUB + BG0SUB) : EASUB),"eV"  ,"Back gate workfunction, will be modified according to NBG later in the code" ) 
`MPRnb( EPSRSUB        ,11.9           ,""                                      ,"Relative dielectric constant of the channel material" ) 
`MPRnb( EPSROX1        ,3.9            ,""                                      ,"Relative dielectric constant of the front gate dielectric" ) 

 // Short Channel Effects
`MPRnb( ASCL           ,0.0            ,""                                      ,"Parameter for back-gate dependent scale length" ) 
`MPRnb( BSCL           ,0.0            ,"V^-1"                                  ,"Parameter for back-gate dependent scale length" ) 
`MPRnb( CIT            ,0.0            ,"F/(m^2)"                               ,"parameter for interface trap" ) 
`MPRnb( CDSC           ,0.14           ,"F/(m^2)"                               ,"coupling capacitance between S/D and channel" ) 
`MPRnb( CDSCD          ,0.14           ,"F/(m^2*V)"                             ,"drain-bias sensitivity of CDSC" ) 
`MPRnb( CBGCBG0        ,0.0            ,"F/(m^2*V)"                             ,"backgate-bias sensitivity of SS for long channel" ) 
`MPRnb( CBGCBG0P       ,0.0            ,"F/(m^2*V^2)"                           ,"backgate-bias sensitivity of SS for long channel" ) 
`MPRnb( CBGCBG         ,0.0            ,"F/(m^2*V)"                             ,"backgate-bias sensitivity of CDSC" ) 
`MPRnb( CBGCBGP        ,0.0            ,"F/(m^2*V^2)"                           ,"Nonlinear backgate-bias sensitivity of SS" ) 
`MPRnb( CBGCBGD        ,0.0            ,"F/(m^2*V^2)"                           ,"backgate-bias sensitivity of CDSCD" ) 
`MPRnb( DVT0           ,19.20          ,""                                      ,"SCE coefficient" ) 
`MPRnb( DVT1           ,0.45           ,""                                      ,"SCE exponent coefficient" ) 
`MPRnb( PHIN           ,0.045          ,"V"                                     ,"Nonuniform vertical doping effect on surface potential" ) 
`MPRnb( ETA0           ,2.00           ,""                                      ,"DIBL coefficient 1" ) 
`MPRnb( DSUB           ,0.375          ,""                                      ,"DIBL coefficient 2 (exponent coefficient)" ) 
`MPRnb( DVTP0          ,0              ,""                                      ,"Coefficient for Drain-Induced Vth Shift (DITS)" ) 
`MPRnb( DVTP1          ,0              ,""                                      ,"DITS exponent coefficient" ) 
`MPRnb( ADVTP0          ,0.0            ,""                                     ,"pre-exponential Coefficient for DITS" ) 
`MPRex( BDVTP0          ,100.0e-9       ,""            ,0                       ,"Exponential coefficient for DITS" ) 
`MPRnb( ADVTP1          ,0.0            ,""                                     ,"pre-exponential coefficient for DVTP1" ) 
`MPRex( BDVTP1          ,100.0e-9       ,""            ,0                       ,"Exponential coefficient for DVTP1" ) 
`MPRnb( DVTP2          ,0.0            ,""                                      ,"DITS Model Parameter" ) 
`MPRnb( ETAB           ,0.00           ,""                                      ,"DIBL coefficient - Back Gate dependence" ) 
`MPRnb( K1RSCE         ,-0.32          ,""                                      ,"Vt Roll-off at moderate Lg" ) 
`MPRnb( LPE0           ,8.2e-9         ,"m"                                     ,"Equivalent length of pocket region at zero bias" ) 
`MPRnb( DSC0           ,0.0            ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" ) 
`MPRnb( DSC1           ,1.00e-9        ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" ) 

// Lateral non-uniform doping effect (IV-CV Vth shift)
`MPRnb( K0             ,0.0            ,"V"                                     ,"Lateral NUD voltage parameter" ) 
`MPRnb( K01            ,0.0            ,"V/K"                                   ,"Temperature dependence of lateral NUD voltage parameter" ) 
`MPRnb( K0SI           ,1.0            ,""                                      ,"Correction factor for strong inversion, used in Mnud, after binning should be from (0:inf)" ) 
`MPRnb( K0SI1          ,0.0            ,"K^-1"                                  ,"Temperature dependence of K0SI" ) 

// Quantum Mechanical Effects
`MPRnb( QMTCENCV       ,0.0            ,""                                      ,"Prefactor + switch for QM Width and Toxeff correction for CV" ) 
`MPRnb( ETAQM          ,0.54           ,""                                      ,"Bulk charge coefficient for Tcen" ) 
`MPRnb( QM0            ,1.00e-3        ,""                                      ,"Knee-Point for Tcen in inversion (Charge normalized to Cox)" ) 
`MPRnb( PQM            ,0.66           ,""                                      ,"Slope of normalized Tcen in inversion" ) 
`MPRco( TOXP           ,EOT1           ,"m"           ,0.1n        ,inf         ,"physical oxide thickness" ) 
       
// Velocity Saturation Model    
`MPRnb( VSAT           ,85000          ,"m/s"                                   ,"Saturation Velocity" ) 
`MPRnb( AVSAT          ,0.0            ,"m/s"                                   ,"" ) 
`MPRex( BVSAT          ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( VSAT1          ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter" ) 
`MPRnb( AVSAT1         ,AVSAT          ,"m/s"                                   ,"" ) 
`MPRex( BVSAT1         ,BVSAT          ,"m"           ,0.0                      ,"" ) 
`MPRnb( VSATCV         ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter for CV" ) 
`MPRnb( AVSATCV        ,AVSAT          ,"m/s"                                   ,"" ) 
`MPRex( BVSATCV        ,BVSAT          ,"m"           ,0.0                      ,"" ) 
`MPRnb( DELTAVSAT      ,1.0            ,"m/s"                                   ,"Velocity saturation parameter" ) 
`MPRnb( KSATIV         ,1.0            ,""                                      ,"Parameter for strong inversion regime for long channel Vdsat" ) 
`MPRnb( KSUBIV         ,1.0            ,""                                      ,"Parameter for weak inversion regime for long channel Vdsat" ) 
`MPRnb( MEXP           ,4.0            ,""                                      ,"Smoothing function factor for Vdsat" ) 
`MPRnb( AMEXP          ,0.0            ,""                                      ,"" ) 
`MPRnb( BMEXP          ,1.0            ,""                                      ,"" ) 
`MPRnb( PTWG           ,0.0            ,"V^-2"                                  ,"Correction factor for velocity saturation" ) 
`MPRnb( APTWG          ,0.0            ,"V^-2"                                  ,"" ) 
`MPRex( BPTWG          ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( AT             ,-1.56e-3       ,""                                      ,"Saturation Velocity Temperature Coefficient" ) 
`MPRnb( ATL            ,0.0            ,""                                      ,"Length scaling for AT" ) 
`MPRnb( TMEXP          ,0.0            ,""                                      ,"" ) 
`MPRnb( PTWGT          ,0.004          ,""                                      ,"" ) 
`MPRnb( PTWGB          ,0.0            ,"V^-3"                                  ,"" ) 
`MPRnb( PTWGB2         ,0.0            ,"V^-3"                                  ,"" ) 
`MPRnb( APTWGB         ,0.0            ,"V^-3"                                  ,"" ) 
`MPRex( BPTWGB         ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( APTWGB2        ,0.0            ,"V^-3"                                  ,"" ) 
`MPRex( BPTWGB2        ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( VSATB          ,0.0            ,"V^-1"                                  ,"" ) 
`MPRnb( ATB            ,0.0            ,""                                      ,"Back bias sensitivity parameter for saturation velocity temperature coefficient" ) 
`MPRnb( ATBL           ,0.0            ,""                                      ,"Length scaling for ATB" ) 
`MPRnb( AVSATB         ,0.0            ,"V^-1"                                  ,"" ) 
`MPRex( BVSATB         ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
   
// Mobility Model 
`MPRex( U0             ,0.03           ,"m^2/(V*s)"   ,0.0                      ,"Low Field Mobility" ) 
`MPRnb( ETAMOB         ,2.0            ,""                                      ,"" ) 
`MPRnb( UP             ,0.0            ,"(um)^LPA"                              ,"" ) 
`MPRnb( LPA            ,1.0            ,""                                      ,"" ) 
`MPRnb( UA             ,0.3            ,"(MV/cm)^(-EU)"                         ,"" ) 
`MPRnb( AUA            ,0.0            ,"(MV/cm)^(-EU)"                         ,"" ) 
`MPRex( BUA            ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( EU             ,2.5            ,"cm/MV"                                 ,"" ) 
`MPRnb( AEU            ,0.0            ,"cm/MV"                                 ,"" ) 
`MPRex( BEU            ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( UC             ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" ) 
`MPRnb( AUC            ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" ) 
`MPRex( BUC            ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( UD             ,0.0            ,""                                      ,"" ) 
`MPRnb( AUD            ,0.0            ,""                                      ,"" ) 
`MPRex( BUD            ,50.0e-9        ,"m"           ,0.0                      ,"" ) 
`MPRnb( UDB            ,0.0            ,"V^-1"                                  ,"" ) 
`MPRnb( AUDB           ,0.0            ,"V^-1"                                  ,"" ) 
`MPRex( BUDB           ,50.0e-9        ,"m"           ,0.0                      ,"" ) 

`MPRnb( UCS            ,1.0            ,""                                      ,"" ) 
`MPRnb( UTE            ,0.0            ,""                                      ,"" ) 
`MPRnb( UTL            ,-1.5e-3        ,""                                      ,"" ) 
`MPRnb( UA1            ,1.032e-3       ,""                                      ,"" ) 
`MPRnb( UC1            ,0.0            ,""                                      ,"" ) 
`MPRnb( UD1            ,0.0            ,""                                      ,"" ) 
`MPRnb( UCSTE          ,-4.775e-3      ,""                                      ,"" ) 
`MPRcc( CHARGEWF       ,0              ,""            ,-1          ,1           ,"Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side" ) 
   
// Access Resistance Model
`MPRnb( RDSWMIN        ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 0 S/D extension resistance per unit width at high Vgs" ) 
`MPRnb( RDSW           ,100.0          ,"ohm*um^WR"                             ,"RDSMOD = 0 zero bias S/D extension resistance per unit width" ) 
`MPRnb( ARDSW          ,0.0            ,"ohm*um^WR"                             ,"" ) 
`MPRex( BRDSW          ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( RSWMIN         ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 1 source extension resistance per unit width at high Vgs" ) 
`MPRnb( RSW            ,50.0           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias source extension resistance per unit width" ) 
`MPRnb( ARSW           ,0.0            ,"ohm*um^W"                              ,"" ) 
`MPRex( BRSW           ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( RDWMIN         ,RSWMIN         ,"ohm*um^WR"                             ,"RDSMOD = 1 drain extension resistance per unit width at high Vgs" ) 
`MPRnb( RDW            ,50.0           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias drain extension resistance per unit width" ) 
`MPRnb( ARDW           ,0.0            ,"ohm*um^WR"                             ,"" ) 
`MPRex( BRDW           ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( PRWG           ,0              ,"V^-1"                                  ,"Gate bias dependence of source/drain extension resistance" ) 
`MPRnb( PRWB           ,0              ,"V^-1"                                  ,"" ) 
`MPRnb( WR             ,1.0            ,"V^-1"                                  ,"W dependence parameter of S/D extension resistance" ) 
`MPRnb( PRT            ,0.001          ,"K^-1"                                  ,"Series Resistance Temperature coefficient" ) 
   
// DIBL Model
`MPRnb( PDIBL1         ,1.30           ,""                                      ,"DIBL Output Conductance parameter" ) 
`MPRnb( PDIBL2         ,2.0e-4         ,""                                      ,"DIBL Output Conductance parameter" ) 
`MPRnb( DROUT          ,1.06           ,""                                      ,"L dependence of DIBL effect on Rout" ) 
`MPRnb( PVAG           ,1.0            ,""                                      ,"Vgs dependence on early voltage" ) 

// Channel Length Modulation Effect
`MPRnb( PCLM           ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter" ) 
`MPRnb( APCLM          ,0.0            ,""                                      ,"" ) 
`MPRex( BPCLM          ,100.0e-9       ,"m"           ,0.0                      ,"" ) 
`MPRnb( PCLMG          ,0.0            ,""                                      ,"Gate bias dependent parameter for channel Length Modulation (CLM)" ) 
`MPRnb( PCLMCV         ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter for C-V" ) 

// Geometry dependent Source/Drain Resistance RGEOMOD=0
`MPRnb( RSHS           ,0.0            ,"ohm"                                   ,"Source-side sheet resistance" ) 
`MPRnb( RSHD           ,RSHS           ,"ohm"                                   ,"Drain-side sheet resistance" ) 

// Gate Tunneling Current, from gate to channel, Igc
`MPRnb( AIGBINV        ,1.11e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"parameter for Igb in inversion" ) 
`MPRnb( BIGBINV        ,9.49e-4        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"parameter for Igb in inversion" ) 
`MPRnb( CIGBINV        ,6.00e-3        ,"V^-1"                                  ,"parameter for Igb in inversion" ) 
`MPRnb( EIGBINV        ,1.1            ,"V"                                     ,"parameter for Igb in inversion" ) 
`MPRnb( NIGBINV        ,3.0            ,""                                      ,"parameter for Igb in inversion" ) 
`MPRnb( AIGBACC        ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"parameter for Igb in accumulation" ) 
`MPRnb( BIGBACC        ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"parameter for Igb in accumulation" ) 
`MPRnb( CIGBACC        ,7.5e-2         ,"V^-1"                                  ,"parameter for Igb in accumulation" ) 
`MPRnb( NIGBACC        ,1.0            ,""                                      ,"parameter for Igb in accumulation" ) 
`MPRnb( AIGC           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"parameter for Igc in inversion" ) 
`MPRnb( BIGC           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"parameter for Igc in inversion" ) 
`MPRnb( CIGC           ,0.075          ,"V^-1"                                  ,"parameter for Igc in inversion" ) 
`MPRnb( PIGCD          ,1.0            ,""                                      ,"parameter for Igc partition" ) 

// Gate Tunneling Current, from gate to S/D, Igs and Igd
`MPRnb( AIGS           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"parameter for Igs, Igd" ) 
`MPRnb( BIGS           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"parameter for Igs, Igd" ) 
`MPRnb( CIGS           ,0.075          ,"V^-1"                                  ,"parameter for Igs, Igd" ) 
`MPRnb( DLCIGS         ,0              ,""                                      ,"Delta L for Igs model" ) 
`MPRnb( DLCIGD         ,DLCIGS         ,""                                      ,"Delta L for Igd model" ) 
`MPRnb( AIGD           ,AIGS           ,"((F*s^2/g)^0.5)*m^-1"                  ,"parameter for Igd in inversion" ) 
`MPRnb( BIGD           ,BIGS           ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"parameter for Igd in inversion" ) 
`MPRnb( CIGD           ,CIGS           ,"V^-1"                                  ,"parameter for Igs, Igd" ) 
`MPRoz( TOXREF         ,1.2n           ,"m"                                     ,"Target tox value" ) 
`MPRnb( NTOX           ,1.0            ,""                                      ,"Exponent for Tox ratio" ) 
`MPRnb( POXEDGE        ,1.0            ,""                                      ,"Factor for the gate edge Tox" ) 

// Gate-induced source/drain leakage
`MPRnb( AGISL          ,6.055p         ,"mho"                                   ,"pre-exponential coeff. for GISL" ) 
`MPRnb( BGISL          ,0.3e9          ,"V/m"                                   ,"exponential coeff. for GISL" ) 
`MPRnb( EGISL          ,0.2            ,"V"                                     ,"band bending parameter for GISL" ) 
`MPRnb( PGISL          ,1.0            ,""                                      ,"parameter for body-bias effect on GISL" ) 
`MPRnb( AGIDL          ,AGISL          ,"mho"                                   ,"pre-exponential coeff. for GIDL" ) 
`MPRnb( BGIDL          ,BGISL          ,"V/m"                                   ,"exponential coeff. for GIDL" ) 
`MPRnb( EGIDL          ,EGISL          ,"V"                                     ,"band bending parameter for GIDL" ) 
`MPRnb( PGIDL          ,PGISL          ,""                                      ,"parameter for body-bias effect on GIDL" ) 

// Impact Ionization Current
`MPRnb( ALPHA0         ,0.0            ,"m/V"                                   ,"first parameter of Iii" ) 
`MPRnb( ALPHA1         ,0.0            ,"V^-1"                                  ,"L scaling parameter of Iii" ) 
`MPRnb( BETA0          ,0.0            ,"V^-1"                                  ,"Vds dependent parameter of Iii" ) 

// Overlap Cap and Fringing Cap
`MPRnb( LOVS           ,0.0            ,"m"                                     ,"Overlap length for fg/s fg/d overlap" ) 
`MPRnb( LOVD           ,LOVS           ,"m"                                     ,"Overlap length for fg/s fg/d overlap" ) 
`MPRnb( CFS            ,0.0            ,"F/m"                                   ,"Outer Fringe Cap" ) 
`MPRnb( CFD            ,CFS            ,"F/m"                                   ,"Outer Fringe Cap" ) 
`MPRcz( CGSL           ,0.0            ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped source region" ) 
`MPRcz( CGDL           ,CGSL           ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped drain region" ) 
`MPRco( CKAPPAS        ,0.6            ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the source side" ) 
`MPRco( CKAPPAD        ,CKAPPAS        ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the drain side" ) 
`MPRnb( CSDBGSW        ,0.0            ,"F/m"                                   ,"Source/drain sidewall fringing capacitance per unit length" ) 

// Back gate biasing effect
// gamma = d_Vth / d_Vbg
// p-well  
`MPRnb( KBG0PW         ,1.0            ,""                                      ,"Length dependence of substrate factor" ) 
`MPRnb( KBG1PW         ,0.0            ,""                                      ,"Length dependence of substrate factor" ) 
`MPRnb( KBG2PW         ,-1.0           ,""                                      ,"Length dependence of substrate factor" ) 
`MPRnb( DBGPW          ,0.12           ,""                                      ,"Length dependence of substrate factor" ) 
`MPRnb( BPFACTORPW     ,0.0            ,""                                      ,"Back-plane (BP) effect, 1 means no BP" ) 
`MPRnb( VKNEE1PW       ,0.0            ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" ) 
`MPRco( VKNEE2PW       ,1.0            ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" ) 

//n-well
`MPRnb( KBG0NW         ,KBG0PW         ,""                                      ,"Length dependence of body factor" ) 
`MPRnb( KBG1NW         ,KBG1PW         ,""                                      ,"Length dependence of body factor" ) 
`MPRnb( KBG2NW         ,KBG2PW         ,""                                      ,"Length dependence of body factor" ) 
`MPRnb( DBGNW          ,DBGPW          ,""                                      ,"Length dependence of body factor" ) 
`MPRnb( BPFACTORNW     ,BPFACTORPW     ,""                                      ,"Back-plane (BP) effect, 1 means no BP" ) 
`MPRnb( VKNEE1NW       ,VKNEE1PW       ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" ) 
`MPRco( VKNEE2NW       ,VKNEE2PW       ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" ) 

// Flicker Noise
`MPRoc( EF             ,1.0            ,""            ,0           ,2           ,"Flicker noise frequency exponent" ) 
`MPRnb( EM             ,4.1e7          ,"V/m"                                   ,"Flicker noise parameter" ) 
`MPRnb( NOIA           ,6.250e+39      ,"eV^-1* s^1-EF *m^-3"                   ,"Flicker noise parameter" ) 
`MPRnb( NOIB           ,3.125e+24      ,"eV^-1* s^1-EF *m^-1"                   ,"Flicker noise parameter" ) 
`MPRnb( NOIC           ,8.750e+07      ,"eV^-1* s^1-EF *m"                      ,"Flicker noise parameter" ) 

// Thermal Noise
`MPRcz( NTNOI          ,1.0            ,""                                      ,"Thermal noise parameter" ) 
`MPRnb( LINTNOI        ,0.0            ,"m"                                     ,"Lint offset for flicker noise calculation" )

// Temperature Effects
`MPRco( TNOM           ,27.0           ,"Celsius"     ,-273.15     ,inf         ,"Temperature at which the model is extracted" ) 
`MPRnb( TBGASUB        ,7.02e-4        ,"eV/K"                                  ,"Bandgap Temperature Coefficient" ) 
`MPRnb( TBGBSUB        ,1108.0         ,"K"                                     ,"Bandgap Temperature Coefficient" ) 
`MPRnb( KT1            ,0.0            ,"V"                                     ,"Vth Temperature Coefficient" ) 
`MPRnb( KT1L           ,0.0            ,"V*m"                                   ,"Vth Temperature L Coefficient" ) 
`MPRnb( KT2            ,0.0            ,""                                      ,"Vth Temperature Vbg Coefficient" ) 
`MPRnb( KT2L           ,0.0            ,"m"                                     ,"Vbg Temperature L Coefficient" ) 
`MPRnb( IIT            ,-0.5           ,""                                      ,"Impact Ionization Temperature Dependence" ) 
`MPRnb( TGIDL          ,-0.003         ,"K^-1"                                  ,"GIDL Temperature Dependence" ) 
`MPRnb( TGISL          ,-0.003         ,"K^-1"                                  ,"GISL Temperature Dependence" ) 
`MPRnb( IGT            ,2.5            ,""                                      ,"Gate Current Temperature Dependence" ) 
`MPRnb( TETA0          ,0.0            ,"K^-1"                                  ,"Temperature Dependence for DIBL effects" ) 
// Self Heating
`MPRnb( RTH0           ,0.01           ,"ohm*m*K/W"                             ,"Thermal resistance" ) 
`MPRnb( CTH0           ,1.0E-05        ,"W*s/m/K"                               ,"Thermal capacitance" ) 
`MPRnb( WTH0           ,0.0            ,"m"                                     ,"Width dependence coefficient for Rth and Cth" ) 

`ifdef __RGATEMOD__
`MPRnb( XGW            ,0.0            ,"m"                                     ,"Dist from gate contact center to dev edge" ) 
`MPRoo( XGL            ,0.0            ,"m"           ,-inf        ,L+XL        ,"Variation in Ldrawn" ) 
`MPIcc( NGCON          ,1              ,""            ,1           ,2           ,"Number of gate contacts" ) 
`MPRcz( RSHG           ,0.1            ,"ohm"                                   ,"Gate sheet resistance" ) 
`endif

// GDSMIN - added for precision
`MPRnb( GDSMIN         ,1.0e-15        ,"mho"                                   ,"Minimum Conductance" ) 

//Binning Parameters

`include "bsimimg_binning.include"


// ***********************************
//   Variables
// ***********************************

// Common Variables
real Lnew, LeffCV, Leff, Weff, WeffCV, Wnew, L_LLN, W_LWN, LW_LLN_LWN, dLIV, L_WLN, W_WWN, LW_WLN_WWN, dWIV, dLCV, dWCV;
real epssi, cox1,cox1P, cox2, csi, epsratio;
real vfgs, vbgs, vbgd, vbgx, vds, sigvds, vbgxpos;
real vgs_noswap, vds_noswap, vgd_noswap, vbgs_noswap, vbgd_noswap;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
real qia,qia2, qba, dqi;
real phib, phisub, deltaphi1, deltaphi2;
real Eg, Vtm;
real beta;
real wf, wr;
real Nc;
real qb0;                          
real dvth_nbody;                         
real tmp,  QMTCENCV_i, Tcen0, Tcen, coxeff;

// Terminal Voltage Conditioning Variables
real vgfb1, vgfb2, vgfb1eff;
real vdsx, symmetry_factor;

// Short Channel Effects
real scl, sclm, sclf, teff, temp;
real vbi, nVtm, dvth_dibl, dvth_vtroll, dvth_rsce, dvth_dsc, dvth_all, phist;
real Theta_SCE, Theta_RSCE, Theta_DIBL;
// DITS Model parameters
real Theta_DITS, DVTP0_i, DVTP1_i ;
//Lateral Non-uniform Doping Effect
real Mnud;


// Temperature Effects
real Tnom, TRatio, delTemp;
real PhiRef, PhiSD, ni;
real dvth_temp, dvth_temp0;
real BETA0_t, BGIDL_t, BGISL_t, igtemp, ETA0_t;



// Drain Saturation Voltage
real qis, qid, qbs, Dmobs, Vdseff;

real eta_mu, eta_mu_cv, Eeffm, Eeffm_cv, Dmob, Dmob_cv, u0, ueff; 
real UA_t, UC_t, UCS_t, UD_t, U0_t, Eeffs, EeffFactor;
real Dr, WeffWRFactor; 
real RSourceGeo, RDrainGeo; 
real RDSWMIN_i, RDWMIN_i, RSWMIN_i; 
real UDB_i ;


`ifdef __RDSMOD__ 
    real Rdrain, Rsource; 
    real gspr, gdpr;
`endif 

real rdstemp, Rdsi, Rdss;
real DIBLfactor, PVAGfactor, diffVds, VaDIBL, Vgst2Vtm, Moc, Mclm, MclmCV; 
real Dvsat, Vdsat, inv_MEXP; 
real VSAT_t,VSATB_t,VSAT1_t, VSATCV_t, MEXP_t, Esat, EsatL, EsatCV, EsatCVL, Esat1, Esat1L; 
real K0_t, K0SI_t;
real WVCox, Ta, Tb, Tc; 
real Xsat; 
real PTWG_t; 
    

// Gate Current
real Vaux_Igbinv, igbinv, igsd_mult, igsd_mult0, igbs, igbd;
real Voxacc, Vaux_Igbacc, vfbzb, igbacc;
real igcs, igcd, igc0, Vdseffx, T1_exp;
real igisl, igidl, vfbsd, igs, igd, vfgs_eff, vfgd_eff;
real Aechvb, Bechvb, Toxratio, Toxratioedge;
real  vgbg;


// Impact Ionization current
real Iii;


// IV Variables
integer devsign, welsign;
real ids, ids0, ids0_ov_dqi;

// CV Variables
real qs, qd, qfg, qbg;
real IMGTOXP;   
real qsi, qdi,qfgi, qbgi;                           
// Parasitic Capacitance
real qfgs_parasitic, qfgd_parasitic, qfgs_ov, qfgs_of, qfgd_ov, qfgd_of;
real vfgs_overlap, vfgd_overlap;
real vgd_ov_noswap, vgs_ov_noswap;
real csbox, cdbox, Qsbg, Qdbg;

// Back-gate biasing effects
real kvbg, vsubdep0, vsubdep, vknee1, vknee2, bpfactor;

// Flicker Noise
real LINTNOI_i;
real litl, Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real NTNOI_i, qinv;
real Gtnoi, sid;
real Nt;

// Self Heating
`ifdef __SHMOD__
    real gth, cth;
`endif
real DevTemp;

//Gate Resistances
`ifdef __RGATEMOD__
    real Grgeltd;
`endif

// Binning
real Inv_L, Inv_W, Inv_WL; 

// Binning
    
real RDSW_i, RDW_i, RSW_i; 
real PRWG_i, PRWB_i, WR_i; 
real PHIG1_i, PHIG2_i; 
real NSD_i, NBODY_i; 
real CIT_i, CDSC_i, CDSCD_i, CBGCBG_i; 
real DVT0_i, DVT1_i, PHIN_i; 
real ETA0_i, ETAB_i, DSUB_i, K1RSCE_i, LPE0_i; 
real K0_i, K01_i, K0SI_i, K0SI1_i, MEXP_i; 
real PTWG_i, PTWGB_i, PTWGB2_i, PTWGT_i; 
real U0_i, UA_i, UC_i, UD_i, UCS_i, EU_i, UTL_i, UTE_i, UA1_i, UD1_i, UCSTE_i; 
real AT_i, ATB_i, PRT_i, IIT_i, TGIDL_i, TGISL_i, IGT_i; 
real PCLM_i, PCLMCV_i, DROUT_i, PDIBL1_i, PDIBL2_i, PVAG_i,  ALPHA0_i, ALPHA1_i, BETA0_i; 
real AIGC_i, BIGC_i, CIGC_i, PIGCD_i; 
real AGISL_i, BGISL_i, EGISL_i, PGISL_i, AGIDL_i, BGIDL_i, EGIDL_i, PGIDL_i; 
real AIGS_i, BIGS_i, CIGS_i, AIGD_i, BIGD_i, CIGD_i; 
real POXEDGE_i, NTOX_i, LOVS_i, LOVD_i, CFS_i, CFD_i; 
real VSAT_i, VSATB_i, VSAT1_i, VSATCV_i; 
real KSATIV_i, KSUBIV_i, UP_i; 
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i; 
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i; 

//new core
real k1,k2,A0,xg1,xg2,PHISsat,xg1g,deltaPHISsat,phifguess; 
real g,dg1,dg2,dg3,f,df;
integer flag_loop;
real deltaold,delta;
real q2,phi2;
real phifsnew,phibsnew;
real phifdnew,phibdnew;
real qfronts,qfrontd,qbacks,qbackd;
real alphad,alphas;
real deltanr,abscri;
real factortransition;
real factordelta;
real qtots,qtotd, ebs, ebd,eba;
real phisguesss,phidguesss,phisats,phisatd;

real phibaux;

//Threshold op-point
real Qis, phit, Vth;
real t1 ,t2 ,t3 ,t4, fx ,f1x ,f2x ,x ,x1 ,xb, j;

//Newton method variables
real q,q1,dq2,qsqrt,dqsqrt,dlogsinhqsq; 
real dq,dqcoth,dqcothqdqsqrt; 
real sinhqsq, dsinhqsq,qsqoversinhqsq,logsinhqsq,dqsqoversinhqsq,dlogsinhqsqdqsqrt;
real aaux,baux,caux,daux,eaux,daaux,dbaux,dcaux,ddaux,deaux;
real phi1;




// Output variables
`OPP( IDS      , "A"   , "Drain-Source current")
`OPP( QFG      , "C"   , "Front Gate Charge")
`OPP( QBG      , "C"   , "Back Gate Charge")
`OPP(  QD      , "C"   , "Drain Charge")
`OPP(  QS      , "C"   , "Source Charge")
`OPP( CFGD     , "F"   , " fg-d MOSFET capacitance")
`OPP( CFGFG    , "F"   , " fg-fg MOSFET capacitance")
`OPP( CFGS     , "F"   , " fg-s MOSFET capacitance")
`OPP( CFGBG    , "F"   , " fg-bg MOSFET capacitance")
`OPP( CBGD     , "F"   , " bg-d MOSFET capacitance")
`OPP( CBGFG    , "F"   , " bg-fg MOSFET capacitance")
`OPP( CBGS     , "F"   , " bg-s MOSFET capacitance")
`OPP( CBGBG    , "F"   , " bg-bg MOSFET capacitance")
`OPP(  CDD     , "F"   , " d-d MOSFET capacitance")
`OPP( CDFG     , "F"   , " d-fg MOSFET capacitance")
`OPP(  CDS     , "F"   , " d-s MOSFET capacitance")
`OPP( CDBG     , "F"   , " d-bg MOSFET capacitance")
`OPP( CSBG     , "F"   , " s-bg MOSFET capacitance")
`OPP( CSFG     , "F"   , " s-fg MOSFET capacitance")
`OPP( QFGI     , "C"   , " Intrinsic Front Gate Charge")
`OPP( QBGI     , "C"   , " Intrinsic Back Gate Charge")
`OPP(  QDI     , "C"   , " Intrinsic Drain Charge")
`OPP(  QSI     , "C"   , " Intrinsic Source Charge")
`OPP(CFGDI     , "F"   , " Intrinsic fg-d MOSFET capacitance")
`OPP(CFGFGI    , "F"   , " Intrinsic fg-fg MOSFET capacitance")
`OPP(CFGSI     , "F"   , " Intrinsic fg-s MOSFET capacitance")
`OPP(CSFGI     , "F"   , " Intrinsic s-fg MOSFET capacitance")
`OPP(CFGBGI    , "F"   , " Intrinsic fg-bg MOSFET capacitance")
`OPP(CBGDI     , "F"   , " Intrinsic bg-d MOSFET capacitance")
`OPP(CBGFGI    , "F"   , " Intrinsic bg-fg MOSFET capacitance")
`OPP(CBGSI     , "F"   , " Intrinsic bg-s MOSFET capacitance")
`OPP(CSBGI     , "F"   , " Intrinsic s-bg MOSFET capacitance")
`OPP(CBGBGI    , "F"   , " Intrinsic bg-bg MOSFET capacitance")
`OPP(CDDI      , "F"   , " Intrinsic d-d MOSFET capacitance")
`OPP(CDFGI     , "F"   , " Intrinsic d-fg MOSFET capacitance")
`OPP( CDSI     , "F"   , " Intrinsic d-s MOSFET capacitance")
`OPP(CDBGI     , "F"   , " Intrinsic d-bg MOSFET capacitance")
`OPP(VTH         , "V"   , " Threshold Voltage")
`OPP( VDSSAT , "V"   , "Drain-Source saturation Voltage")
`OPP( GM        , "A/V"   , "Transconductance")
`OPP( GDS      , "A/V"   , "Output conductance")
`OPP( GMBS   , "A/V"   , "Body transconductance")
//================================================
// analog block begins   
//================================================

analog begin

    /************************************************/
    /*   Geometry dependent calculations follow     */
    /************************************************/
    
    // Variable Initialization
`ifdef __RDSMOD__ 
    Rdrain  = 0;    Rsource = 0; 
    gspr    = 0 ;   gdpr    = 0;
`endif 
`ifdef __RGATEMOD__
    Grgeltd = 0;
`endif

    if( TYPE == `ntype ) begin devsign =  1;
    end else begin             devsign = -1;
    end
    
    if( WELLTYPE == `ntype ) begin welsign =  1;
    end else begin                 welsign = -1;
    end

    // Constants 
    epssi  = EPSRSUB * `EPS0;

    // W calculation for different NFMOD options
    if (NFMOD == 0) begin Wnew = W/NF ;
    end else begin Wnew = W ;
    end     
       
    //Leff and Weff for IV and CV
    Lnew        = L + XL;
    Wnew        = Wnew +XW;
    L_LLN       = pow(Lnew, -LLN);
    W_LWN       = pow(Wnew, -LWN);
    LW_LLN_LWN  = L_LLN*W_LWN;
    dLIV        = LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;
    L_WLN       = pow(Lnew, -WLN);
    W_WWN       = pow(Wnew, -WWN);
    LW_WLN_WWN  = L_WLN*W_WWN;
    dWIV        = WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;

    Leff    = Lnew - 2.0*dLIV;
    if (Leff <= 0) begin
        $strobe("Fatal: Effective channel length = %e for  %M is non-positive", Leff);
        $finish(0);
    end else if (Leff<=1.0e-9) begin
        $strobe("Warning: Effective channel length = %e for  %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);
    end

    Weff    = Wnew - 2.0*dWIV;
    if (Weff <= 0) begin
        $strobe("Fatal: Effective channel Width = %e for  %M is non-positive", Weff);
        $finish(0);
    end else if (Weff<=1.0e-9) begin
        $strobe("Warning: Effective channel width = %e for  %M is <= 1.0e-9. Recommended Weff >= 1e-8", Leff);
    end

    //Leff and Weff for CV
    dLCV    = DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
    dWCV    = DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
    LeffCV  = Lnew - 2.0*dLCV;

    if (LeffCV <= 0) begin
        $strobe("Fatal: Effective channel length for CV = %e for  %M is non-positive", LeffCV);
        $finish(0);
    end else if (LeffCV<=1.0e-9) begin
        $strobe("Warning: Effective channel length for CV = %e for  %M is <= 1.0e-9. Recommended Leff >= 1e-8", LeffCV);
    end

    WeffCV  = Wnew - 2.0*dWCV;
    if (WeffCV <= 0) begin
        $strobe("Fatal: Effective channel width for CV = %e for  %M is non-positive", WeffCV);
        $finish(0);
    end else if (WeffCV<=1.0e-9) begin
        $strobe("Warning: Effective channel width for CV = %e for  %M is <= 1.0e-9. Recommended Weff >= 1e-8", WeffCV);
    end

    // Binning
    Inv_L       = 1e-6 / Leff;
    Inv_W       = 1e-6 / Weff;
    Inv_WL      = Inv_L * Inv_W;
    //Binning calculations
    RDSW_i      = RDSW + LRDSW * Inv_L + WRDSW * Inv_W + PRDSW * Inv_WL; 
    RDW_i       = RDW + LRDW * Inv_L + WRDW * Inv_W + PRDW * Inv_WL; 
    RSW_i       = RSW + LRSW * Inv_L + WRSW * Inv_W + PRSW * Inv_WL; 
    PRWG_i      = PRWG + LPRWG * Inv_L + WPRWG * Inv_W + PPRWG * Inv_WL; 
    PRWB_i      = PRWB + LPRWB * Inv_L + WPRWB * Inv_W + PPRWB * Inv_WL; 
    WR_i        = WR + LWR * Inv_L + WWR * Inv_W + PWR * Inv_WL; 
    PHIG1_i     = PHIG1 + LPHIG1 * Inv_L + WPHIG1 * Inv_W + PPHIG1 * Inv_WL; 
    PHIG2_i     = PHIG2 + LPHIG2 * Inv_L + WPHIG2 * Inv_W + PPHIG2 * Inv_WL; 
    NSD_i       = NSD + LNSD * Inv_L + WNSD * Inv_W + PNSD * Inv_WL; 
    NBODY_i     = NBODY + LNBODY * Inv_L + WNBODY * Inv_W + PNBODY * Inv_WL; 
    CIT_i       = CIT + LCIT * Inv_L + WCIT * Inv_W + PCIT * Inv_WL; 
    CDSC_i      = CDSC + LCDSC * Inv_L + WCDSC * Inv_W + PCDSC * Inv_WL; 
    CDSCD_i     = CDSCD + LCDSCD * Inv_L + WCDSCD * Inv_W + PCDSCD * Inv_WL; 
    CBGCBG_i    = CBGCBG + LCBGCBG * Inv_L + WCBGCBG * Inv_W + PCBGCBG * Inv_WL; 
    DVT0_i      = DVT0 + LDVT0 * Inv_L + WDVT0 * Inv_W + PDVT0 * Inv_WL; 
    DVT1_i      = DVT1 + LDVT1 * Inv_L + WDVT1 * Inv_W + PDVT1 * Inv_WL; 
    PHIN_i      = PHIN + LPHIN * Inv_L + WPHIN * Inv_W + PPHIN * Inv_WL; 
    ETA0_i      = ETA0 + LETA0 * Inv_L + WETA0 * Inv_W + PETA0 * Inv_WL; 
    ETAB_i      = ETAB + LETAB * Inv_L + WETAB * Inv_W + PETAB * Inv_WL; 
    DSUB_i      = DSUB + LDSUB * Inv_L + WDSUB * Inv_W + PDSUB * Inv_WL; 
    K1RSCE_i    = K1RSCE + LK1RSCE * Inv_L + WK1RSCE * Inv_W + PK1RSCE * Inv_WL; 
    LPE0_i      = LPE0 + LLPE0 * Inv_L + WLPE0 * Inv_W + PLPE0 * Inv_WL; 
    MEXP_i      = MEXP + LMEXP * Inv_L + WMEXP * Inv_W + PMEXP * Inv_WL; 
    K0_i        = K0    + LK0    * Inv_L + WK0    * Inv_W + PK0    * Inv_WL; 
    K01_i       = K01   + LK01   * Inv_L + WK01   * Inv_W + PK01   * Inv_WL; 
    K0SI_i      = K0SI  + LK0SI  * Inv_L + WK0SI  * Inv_W + PK0SI  * Inv_WL; 
    K0SI1_i     = K0SI1 + LK0SI1 * Inv_L + WK0SI1 * Inv_W + PK0SI1 * Inv_WL; 
    PTWG_i      = PTWG + LPTWG * Inv_L + WPTWG * Inv_W + PPTWG * Inv_WL; 
    PTWGB_i     = PTWGB + LPTWGB * Inv_L + WPTWGB * Inv_W + PPTWGB * Inv_WL; 
    PTWGB2_i    = PTWGB2 + LPTWGB2 * Inv_L + WPTWGB2 * Inv_W + PPTWGB2 * Inv_WL; 
    PTWGT_i     = PTWGT + LPTWGT * Inv_L + WPTWGT * Inv_W + PPTWGT * Inv_WL; 
    U0_i        = U0 + LU0 * Inv_L + WU0 * Inv_W + PU0 * Inv_WL; 
    UA_i        = UA + LUA * Inv_L + WUA * Inv_W + PUA * Inv_WL; 
    UC_i        = UC + LUC * Inv_L + WUC * Inv_W + PUC * Inv_WL; 
    UD_i        = UD + LUD * Inv_L + WUD * Inv_W + PUD * Inv_WL; 
    UCS_i       = UCS + LUCS * Inv_L + WUCS * Inv_W + PUCS * Inv_WL; 
    EU_i        = EU + LEU * Inv_L + WEU * Inv_W + PEU * Inv_WL; 
    UTL_i       = UTL + LUTL * Inv_L + WUTL * Inv_W + PUTL * Inv_WL; 
    UTE_i       = UTE + LUTE * Inv_L + WUTE * Inv_W + PUTE * Inv_WL; 
    UA1_i       = UA1 + LUA1 * Inv_L + WUA1 * Inv_W + PUA1 * Inv_WL; 
    UD1_i       = UD1 + LUD1 * Inv_L + WUD1 * Inv_W + PUD1 * Inv_WL; 
    UCSTE_i     = UCSTE + LUCSTE * Inv_L + WUCSTE * Inv_W + PUCSTE * Inv_WL; 
    AT_i        = AT + LAT * Inv_L + WAT * Inv_W + PAT * Inv_WL; 
    ATB_i       = ATB + LATB * Inv_L + WATB * Inv_W + PATB * Inv_WL; 
    PRT_i       = PRT + LPRT * Inv_L + WPRT * Inv_W + PPRT * Inv_WL; 
    IIT_i       = IIT + LIIT * Inv_L + WIIT * Inv_W + PIIT * Inv_WL; 
    TGIDL_i     = TGIDL + LTGIDL * Inv_L + WTGIDL * Inv_W + PTGIDL * Inv_WL; 
    TGISL_i     = TGISL + LTGISL * Inv_L + WTGISL * Inv_W + PTGISL * Inv_WL; 
    IGT_i       = IGT + LIGT * Inv_L + WIGT * Inv_W + PIGT * Inv_WL; 
    PCLM_i      = PCLM + LPCLM * Inv_L + WPCLM * Inv_W + PPCLM * Inv_WL; 
    PCLMCV_i    = PCLMCV + LPCLMCV * Inv_L + WPCLMCV * Inv_W + PPCLMCV * Inv_WL; 
    DROUT_i     = DROUT + LDROUT * Inv_L + WDROUT * Inv_W + PDROUT * Inv_WL; 
    PDIBL1_i    = PDIBL1 + LPDIBL1 * Inv_L + WPDIBL1 * Inv_W + PPDIBL1 * Inv_WL; 
    PDIBL2_i    = PDIBL2 + LPDIBL2 * Inv_L + WPDIBL2 * Inv_W + PPDIBL2 * Inv_WL; 
    PVAG_i      = PVAG + LPVAG * Inv_L + WPVAG * Inv_W + PPVAG * Inv_WL; 
    ALPHA0_i    = ALPHA0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_WL; 
    ALPHA1_i    = ALPHA1 + LALPHA1 * Inv_L + WALPHA1 * Inv_W + PALPHA1 * Inv_WL; 
    BETA0_i     = BETA0 + LBETA0 * Inv_L + WBETA0 * Inv_W + PBETA0 * Inv_WL; 
    AIGBINV_i   =  AIGBINV + Inv_L * LAIGBINV + Inv_W * WAIGBINV + Inv_WL * PAIGBINV; 
    BIGBINV_i   =  BIGBINV + Inv_L * LBIGBINV + Inv_W * WBIGBINV + Inv_WL * PBIGBINV; 
    CIGBINV_i   =  CIGBINV + Inv_L * LCIGBINV + Inv_W * WCIGBINV + Inv_WL * PCIGBINV; 
    EIGBINV_i   =  EIGBINV + Inv_L * LEIGBINV + Inv_W * WEIGBINV + Inv_WL * PEIGBINV; 
    NIGBINV_i   =  NIGBINV + Inv_L * LNIGBINV + Inv_W * WNIGBINV + Inv_WL * PNIGBINV; 
    AIGBACC_i   =  AIGBACC + Inv_L * LAIGBACC + Inv_W * WAIGBACC + Inv_WL * PAIGBACC; 
    BIGBACC_i   =  BIGBACC + Inv_L * LBIGBACC + Inv_W * WBIGBACC + Inv_WL * PBIGBACC; 
    CIGBACC_i   =  CIGBACC + Inv_L * LCIGBACC + Inv_W * WCIGBACC + Inv_WL * PCIGBACC; 
    NIGBACC_i   =  NIGBACC + Inv_L * LNIGBACC + Inv_W * WNIGBACC + Inv_WL * PNIGBACC; 
    AIGC_i      = AIGC + LAIGC * Inv_L + WAIGC * Inv_W + PAIGC * Inv_WL; 
    BIGC_i      = BIGC + LBIGC * Inv_L + WBIGC * Inv_W + PBIGC * Inv_WL; 
    CIGC_i      = CIGC + LCIGC * Inv_L + WCIGC * Inv_W + PCIGC * Inv_WL; 
    PIGCD_i     = PIGCD + LPIGCD * Inv_L + WPIGCD * Inv_W + PPIGCD * Inv_WL; 
    PGIDL_i     = PGIDL + LPGIDL * Inv_L + WPGIDL * Inv_W + PPGIDL * Inv_WL; 
    AGISL_i     = AGISL + LAGISL * Inv_L + WAGISL * Inv_W + PAGISL * Inv_WL; 
    BGISL_i     = BGISL + LBGISL * Inv_L + WBGISL * Inv_W + PBGISL * Inv_WL; 
    EGISL_i     = EGISL + LEGISL * Inv_L + WEGISL * Inv_W + PEGISL * Inv_WL; 
    PGISL_i     = PGISL + LPGISL * Inv_L + WPGISL * Inv_W + PPGISL * Inv_WL; 
    AGIDL_i     = AGIDL + LAGIDL * Inv_L + WAGIDL * Inv_W + PAGIDL * Inv_WL; 
    BGIDL_i     = BGIDL + LBGIDL * Inv_L + WBGIDL * Inv_W + PBGIDL * Inv_WL; 
    EGIDL_i     = EGIDL + LEGIDL * Inv_L + WEGIDL * Inv_W + PEGIDL * Inv_WL; 
    AIGS_i      = AIGS + LAIGS * Inv_L + WAIGS * Inv_W + PAIGS * Inv_WL; 
    BIGS_i      = BIGS + LBIGS * Inv_L + WBIGS * Inv_W + PBIGS * Inv_WL; 
    CIGS_i      = CIGS + LCIGS * Inv_L + WCIGS * Inv_W + PCIGS * Inv_WL; 
    AIGD_i      = AIGD + LAIGD * Inv_L + WAIGD * Inv_W + PAIGD * Inv_WL; 
    BIGD_i      = BIGD + LBIGD * Inv_L + WBIGD * Inv_W + PBIGD * Inv_WL; 
    CIGD_i      = CIGD + LCIGD * Inv_L + WCIGD * Inv_W + PCIGD * Inv_WL; 
    NTOX_i      = NTOX + LNTOX * Inv_L + WNTOX * Inv_W + PNTOX * Inv_WL; 
    POXEDGE_i   = POXEDGE + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_WL; 
    LOVS_i      = LOVS + LLOVS * Inv_L + WLOVS * Inv_W + PLOVS * Inv_WL; 
    LOVD_i      = LOVD + LLOVD * Inv_L + WLOVD * Inv_W + PLOVD * Inv_WL; 
    CFS_i       = CFS + LCFS * Inv_L + WCFS * Inv_W + PCFS * Inv_WL; 
    CFD_i       = CFD + LCFD * Inv_L + WCFD * Inv_W + PCFD * Inv_WL; 
    VSAT_i      = VSAT + LVSAT * Inv_L + WVSAT * Inv_W + PVSAT * Inv_WL; 
    VSATB_i     = VSATB + LVSATB * Inv_L + WVSATB * Inv_W + PVSATB * Inv_WL; 
    VSAT1_i     = VSAT1 + LVSAT1 * Inv_L + WVSAT1 * Inv_W + PVSAT1 * Inv_WL; 
    VSATCV_i    = VSATCV + LVSATCV * Inv_L + WVSATCV * Inv_W + PVSATCV * Inv_WL; 
    KSATIV_i    = KSATIV + LKSATIV * Inv_L + WKSATIV * Inv_W + PKSATIV * Inv_WL; 
    KSUBIV_i    = KSUBIV + LKSUBIV * Inv_L + WKSUBIV * Inv_W + PKSUBIV * Inv_WL; 
    UP_i        = UP + LUP * Inv_L + WUP * Inv_W + PUP * Inv_WL; 
    QMTCENCV_i  = QMTCENCV;


    cox1        = 3.9 * `EPS0 / EOT1;
    cox1P       = 3.9 * `EPS0 / EOT1P;
    cox2        = 3.9 * `EPS0 / EOT2;
    csi         = epssi / TSI;
    epsratio    = EPSRSUB / 3.9;
        
    //Physical Oxide Thickness                      
    if (!$param_given(EOT1P)) begin
        IMGTOXP =(EOT1*EPSROX1/3.9) - DTOX1;                        // valid for any dielectric
    end else begin
        IMGTOXP =EOT1P;
    end
        

    // Geometrical scaling
    if(LPA > 0) begin 
        U0_i = U0_i * (1 - UP_i * pow(Leff, -LPA)); 
    end else begin       
        U0_i = U0_i * (1 - UP_i);
    end 
    UA_i    = UA_i + AUA * lexp(-Leff / BUA); 
    UC_i    = UC_i + AUC * lexp(-Leff / BUC); 
    UDB_i   = UDB + AUDB * lexp(-Leff / BUDB); 
    UD_i    = UD_i + AUD * lexp(-Leff / BUD); 
    EU_i    = EU_i + AEU * lexp(-Leff / BEU);
     
     
`ifdef __RDSMOD__ 
    if(RDSMOD == 1) begin 
        RSW_i = RSW_i + ARSW * lexp(-Leff / BRSW); 
        RDW_i = RDW_i + ARDW * lexp(-Leff / BRDW); 
    end else begin 
`endif 

    RDSW_i = RDSW_i + ARDSW * lexp(-Leff / BRDSW); 
`ifdef __RDSMOD__ 
    end 
`else 
    if(RDSMOD != 0) begin
        $strobe("Although the model selector RDSMOD is set to 1, the external source/drain resistance model is not activated in the Verilog-A code.             Please uncomment \"`define __RDSMOD__\" in bsimimg.va to activate it.");
    end 
`endif 

     
    PCLM_i  = PCLM_i + APCLM * lexp(-Leff / BPCLM); 
    MEXP_i  = MEXP_i + AMEXP * pow(Leff * 1e6, -BMEXP); 
    PTWG_i  = PTWG_i + APTWG * lexp(-Leff / BPTWG); 
    PTWGB_i = PTWGB_i + APTWGB * lexp(-Leff / BPTWGB); 
    PTWGB2_i= PTWGB2_i + APTWGB2 * lexp(-Leff / BPTWGB2); 
    VSAT_i  = VSAT_i + AVSAT * lexp(-Leff / BVSAT); 
    VSATB_i = VSATB_i + AVSATB * lexp(-Leff / BVSATB); 
    VSAT1_i = VSAT1_i + AVSAT1 * lexp(-Leff / BVSAT1); 
    VSATCV_i= VSATCV_i + AVSATCV * lexp(-Leff / BVSATCV); 
    //Scaling for DITS Parameters
    DVTP0_i  = DVTP0 + ADVTP0 * lexp(-Leff / BDVTP0);
    DVTP1_i  = DVTP1 + ADVTP1 * lexp(-Leff / BDVTP1);

    // ====================
    // Parameter checking
    // ====================
    begin: ParameterCheck
        if(U0_i < 0) begin 
            $strobe("Warning: U0_i = %e is negative, setting it to default value", U0_i); 
            U0_i = 0.03; 
        end 
        if(UA_i < 0) begin 
            $strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i); 
            UA_i = 0; 
        end 
        if(EU_i < 0) begin 
            $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i); 
            EU_i = 0; 
        end 
        if(UD_i < 0) begin 
            $strobe("Warning: UD_i = %e is negative, setting it to 0.", UD_i); 
            UD_i = 0; 
        end 
        if(UCS_i < 0) begin 
            $strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i); 
            UCS_i = 0; 
        end
        if(VSATB_i < 0) begin 
            $strobe("Warning: VSATB_i = %e is negative, setting it to 0.", VSATB_i); 
            VSATB_i = 0; 
        end
     
        RDSWMIN_i = RDSWMIN; 
        if(RDSWMIN_i < 0) begin 
            $strobe("Warning: RDSWMIN = %e is negative.  Set to zero", RDSWMIN_i); 
            RDSWMIN_i = 0; 
        end 
        if(RDSW_i < 0) begin 
            $strobe("Warning: RDSW_i = %e is negative.  Set to zero", RDSW_i); 
            RDSW_i = 0; 
        end 
        RSWMIN_i = RSWMIN; 
        if(RSWMIN_i < 0) begin 
            $strobe("Warning: RSWMIN = %e is negative.  Set to zero", RSWMIN_i); 
            RSWMIN_i = 0; 
        end 
        if(RSW_i < 0) begin 
            $strobe("Warning: RSW_i = %e is negative.  Set to zero", RSW_i); 
            RSW_i = 0; 
        end 
        RDWMIN_i = RDWMIN; 
        if(RDWMIN_i < 0) begin 
            $strobe("Warning: RDWMIN = %e is negative.  Set to zero", RDWMIN_i); 
            RDWMIN_i = 0; 
        end 
        if(RDW_i < 0) begin 
            $strobe("Warning: RDW_i = %e is negative.  Set to zero", RDW_i); 
            RDW_i = 0; 
        end 
        if(PRWG_i < 0) begin 
            $strobe("Warning: PRWG_i = %e is negative.  Set to zero", PRWG_i); 
            PRWG_i = 0; 
        end
        if(PDIBL1_i < 0) begin 
            $strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i); 
        end 
        if(PDIBL2_i < 0) begin 
            $strobe("Warning: PDIBL2_i = %e is negative.", PDIBL2_i); 
        end 
        if(DROUT_i <= 0) begin 
            $strobe("Warning: DROUT_i = %e is not positive.", DROUT_i); 
        end  
        if(MEXP_i < 2.0) begin 
            $strobe("Warning: MEXP_i = %e < 2.  Setting MEXP_i = 2.", MEXP_i); 
            MEXP_i = 2.0; 
        end
        if(EF <= 0) begin
            $strobe("Warning: EF = %e is non-positive.", EF);
        end else if(EF > 2.0) begin
            $strobe("Warning: EF = %e > 2.0.", EF);
        end
    end //Parameter Checking Ends

    // Short Channel Effects
    Theta_RSCE  = sqrt(1.0 + LPE0_i / Leff) - 1.0;
    teff        = TSI + epsratio * (EOT1 + EOT2);

    // Variable to be used in Drain Saturation Voltage
    inv_MEXP    = 1.0 / MEXP_i;
    
    // Source/drain to substrate parasitic capacitances
    csbox       = cox2 * AS;
    cdbox       = cox2 * AD;
    T0          = CSDBGSW * lln(1.0 + TSI / EOT2);
    csbox       = csbox + T0 * max(PS - W, 0);
    cdbox       = cdbox + T0 * max(PD - W, 0);  
    csbox = max(csbox, 0.01e-18) ;    // for better convergence
    cdbox = max(cdbox, 0.01e-18) ;    // for better convergence

    // Mobility Degradation  
    eta_mu      = 0.5 * ETAMOB; 
    eta_mu_cv   =  0.5; 
    if( TYPE != `ntype ) begin
        eta_mu    = 1.0 / 3.0 * ETAMOB;
        eta_mu_cv =  1.0 / 3.0; 
    end 

    EeffFactor  = 1.0e-8 / (epsratio * (EOT1));
    WeffWRFactor    = 1.0 / (pow((Weff)*1.0e6, WR_i) * (NF));
    litl        =  sqrt(epsratio * EOT1* TSI); 

    
    if(LINTNOI >= Leff/2) begin
        $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
        LINTNOI_i  =  0;
    end else begin
        LINTNOI_i  =  LINTNOI;
    end
    if(NTNOI < 0) begin
        $strobe("Warning: NTNOI = %e is negative. Set to zero.", NTNOI);
        NTNOI_i  =  0;
    end else begin
        NTNOI_i  =  NTNOI;
    end
    
        
    // Self-heating Model                      
`ifdef __SHMOD__
    if(SHMOD != 0 && RTH0 > 0) begin
        gth = (WTH0 + Weff * NF) / RTH0;
        cth = CTH0 * (WTH0 + Weff * NF);
    end else begin
        gth = 1.0;                                  // set gth to a value to prevent a singular G matrix
        cth = 0.0;
    end
`else
    if(SHMOD != 0) begin
        $strobe("Although the model selector SHMOD is set to 1, the self heating model is not activated in the Verilog-A code.  Please uncomment  \"`define __SHMOD__\" in bsimimg.va to activate it.");
    end
`endif

    // Geometry dependent Source/Drain Resistance
    RSourceGeo = RSHS * NRS;
    RDrainGeo  = RSHD * NRD;

    //Tnom
    if(TNOM <= 0) begin
        $strobe("Warning: TNOM = %e is not positive. Set to 300.15 K.", TNOM);
        Tnom = `REFTEMP;
    end else begin
        Tnom = TNOM + `CONSTCtoK;
    end

    // Gate current
    if(TYPE == `ntype) begin Aechvb = 4.97232e-7; //NMOS
    end else begin           Aechvb = 3.42537e-7; //PMOS
    end 
    if(TYPE == `ntype) begin Bechvb = 7.45669e11; //NMOS
    end else begin           Bechvb = 1.16645e12; //PMOS
    end

    T0      = TOXP * TOXP;
    T1      = TOXP * POXEDGE_i;
    T2      = T1 * T1;
    Toxratio    = lexp(NTOX_i * lln(TOXREF / TOXP)) / T0;
    Toxratioedge    = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
    igsd_mult0      = Weff * Aechvb * Toxratioedge;

    

    // Gate process resistance
`ifdef __RGATEMOD__ 
    Grgeltd = RSHG * (XGW + Weff / 3.0 / NGCON)/ ( NGCON * NF * (Lnew - XGL));
    if (Grgeltd > 0.0) begin
        Grgeltd = 1.0 / Grgeltd;
    end else begin
        Grgeltd = 1.0e3; /* mho */
    if (RGATEMOD != 0) begin
        $strobe("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
    end
    end
`else
    if(RGATEMOD != 0) begin
        $strobe("Although the model selector RGATEMOD is set to %d, the gate resistance model is not activated in the Verilog-A code.  Please             uncomment \"`define __RGATEMOD__\" in bsimimg.va to activate it.",RGATEMOD);
    end
`endif

    /************************************************/
    /*   Temperature dependent calculations follow  */
    /************************************************/
`ifdef __SHMOD__
    if(SHMOD != 0 && RTH0 > 0) begin
        DevTemp = $temperature + Temp(rth_branch) + DTEMP;
    end else begin
`endif
        DevTemp = $temperature + DTEMP;
`ifdef __SHMOD__
    end
`endif

    begin : IMGTempDepCalc

        TRatio  = DevTemp / Tnom;
        delTemp = DevTemp - Tnom;

        // Temperature Dependent Physical Quantities
        Vtm     = `KboQ * DevTemp;
        Eg      = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
        T1      = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
        ni      = NI0SUB * T1 * lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
        Nc      = NC0SUB*T1 ;
        vbi     = Vtm * lln(NSD_i * NBODY_i / (ni * ni));
        phib    = Vtm * lln(NBODY_i / ni);
        phisub  = (0.5*Eg-hypsmooth(0.5*Eg-Vtm*lln(NBG/ni),1.0E-4));


        // Front- and Back-Gate Workfunctions
        if ((NBG!=0) & (!$param_given(PHIG2)))  begin   
            if (WELLTYPE == `ptype) begin
                    PHIG2_i  = PHIG2_i - 0.5*BG0SUB + phisub;       // Back Gate Workfunction tuning, eV
            end else begin
                    PHIG2_i  = PHIG2_i + 0.5*BG0SUB - phisub;
            end
        end

        PhiRef   = (TYPE == `ntype) ? EASUB : EASUB + Eg;
        //PhiRef = EASUB + Eg/2;
        deltaphi1= devsign * (PHIG1_i - PhiRef);
        deltaphi2= devsign * (PHIG2_i - PhiRef);
        PhiSD    = EASUB + Eg/2 - devsign * min(Eg/2, Vtm*lln(NSD_i/ni));
        vfbsd    = devsign * (PHIG1_i - PhiSD);                 // for GIDL and COV Calculation


        // Temperature Effects
        U0_t    = U0_i * pow(TRatio, UTE_i) * (1.0 + hypsmooth(0.9+ UTL_i*delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
        u0      = U0_t; 
        UC_t    = UC_i * hypsmooth(1.0 + UC1*delTemp - 1.0E-6, 1.0E-3); 
        UA_t    = UA_i * hypsmooth(1.0 + UA1_i*delTemp - 1.0E-6, 1.0E-3); 
        UD_t    = UD_i * pow(TRatio, UD1_i); 
        UCS_t   = UCS_i * pow(TRatio, UCSTE_i); 
        
        rdstemp = hypsmooth(1.0 + PRT_i * delTemp - 1.0E-6, 1.0E-3); 
        AT_i    = AT_i *(1.0 +  Inv_L * ATL); 
        VSAT_t  = VSAT_i * (1.0 + hypsmooth(0.9 - AT_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
        if(VSAT_t < 1000) begin 
            $strobe("Warning: VSAT(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT_t); 
            VSAT_t = 1000; 
        end 
        VSAT1_t = VSAT1_i * (1.0 + hypsmooth(0.9 - AT_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
        if(VSAT1_t < 1000) begin 
            $strobe("Warning: VSAT1(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1_t); 
            VSAT1_t = 1000; 
        end

        VSATCV_t = VSATCV_i * (1.0 + hypsmooth(0.9 - AT_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
        if(VSATCV_t < 1000) begin 
            $strobe("Warning: VSATCV(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSATCV_t); 
            VSATCV_t = 1000; 
        end 
        ETA0_t      =  ETA0_i  * (1.0 + hypmax( TETA0  *delTemp, -0.9, 1e-4));
        ATB_i       = ATB_i *(1.0 +  Inv_L * ATBL);    
        VSATB_t     = VSATB_i * (1.0 + hypsmooth(0.9 - ATB_i *delTemp, 1.0E-3) - hypsmooth(0.9, 1.0E-3)); 
        MEXP_t      = hypsmooth(MEXP_i * (1.0 + TMEXP * delTemp)-2.0 , 1.0E-3) + 2.0;
        K0_t        =  K0_i    + K01_i * delTemp;
        K0SI_t      =  K0SI_i  + hypmax(K0SI1_i  * delTemp, -K0SI_i,  1E-6); 
        PTWG_t      = PTWG_i * hypsmooth(1.0 - PTWGT_i*delTemp - 1.0E-6, 1.0E-3); 
        dvth_temp0  = (KT1 + KT1L / Leff) * (TRatio - 1.0);
        BETA0_t     = BETA0_i * pow(TRatio, IIT_i);
        BGIDL_t     = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0E-6, 1.0E-3);
        BGISL_t     = BGISL_i * hypsmooth(1.0 + TGISL_i * delTemp - 1.0E-6, 1.0E-3);
        igtemp      = lexp(IGT_i * lln(TRatio)); //pow(TRatio, IGT_i);
        igsd_mult   =  igsd_mult0 * igtemp;
        
    end //End of IMGTempDepCalc

    /************************************************/
    /*  Bias dependent calculations follow          */
    /************************************************/

    // Load Terminal Voltages
    vgs_noswap  = devsign * V(`IntrinsicGate, `IntrinsicSource);
    vds_noswap  = devsign * V(`IntrinsicDrain, `IntrinsicSource);
    vgd_noswap  = devsign * V(`IntrinsicGate, `IntrinsicDrain);
    vbgs_noswap = devsign * V(bg, `IntrinsicSource);
    vbgd_noswap = devsign * V(bg, `IntrinsicDrain);
    vds         = devsign * V(`IntrinsicDrain, `IntrinsicSource);
    vgbg        = devsign * V(`IntrinsicGate, bg);  

    // Source-drain Interchange
    sigvds      = 1.0;
    if(vds < 0.0) begin
        sigvds  = -1.0;
        vfgs    = vgd_noswap;
        vbgs    = vbgd_noswap;
        vbgd    = vbgs_noswap;
        vds     = -1.0 * vds;
    end else begin
        vfgs    = vgs_noswap;
        vbgs    = vbgs_noswap;
        vbgd    = vbgd_noswap;
    end

`ifdef __RGATEMOD__
    vgd_ov_noswap = devsign * V(`GateEdgeNode, `IntrinsicDrain);
    vgs_ov_noswap = devsign * V(`GateEdgeNode, `IntrinsicSource);
`else
    vgd_ov_noswap = vgd_noswap;
    vgs_ov_noswap = vgs_noswap;
`endif

    //  Terminal Voltage Conditioning
    vdsx        = sqrt(vds * vds + 0.0004) - 0.02;
    symmetry_factor = 0.5 * (vdsx - vds);
    vbgx        = vbgs + symmetry_factor; 
    vgfb1       = vfgs - deltaphi1;  
    vgfb2       = vbgs - deltaphi2;

    // Back-gate bias dependence
    sclf    = sqrt(epsratio * TSI * EOT1);
    sclm    = sqrt(TSI * (epsratio * EOT1 + 0.375 * TSI));
    T0      = (vgfb1 * (EOT2 * epsratio) + vgfb2 * (EOT1 * epsratio + TSI)) / teff + symmetry_factor;
    T1      = atan(ASCL + BSCL * T0) / `M_PI + 0.5;
    scl     = sclm + T1 * (sclf - sclm);

    tmp     = DVT1_i * Leff / scl + 1.0e-6;             
    if (tmp < 40.0) begin
        Theta_SCE = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_SCE = exp(-tmp);
    end

    tmp     = DSUB_i * Leff / scl + 1.0e-6;             
    if (tmp < 40.0) begin
        Theta_DIBL = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_DIBL = exp(-tmp);
    end
    if (tmp < 40.0)
         T0   =  1.0 /max((1.0 + DVTP2 * (cosh(tmp) - 2.0)), 1.0e-6);
    else
         T0   =  exp(-tmp)/max((exp(-tmp) + DVTP2), 1.0e-6);
    Theta_DITS = T0 ;
    
    tmp = DROUT_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        DIBLfactor = 0.5 * PDIBL1_i / (cosh(tmp) - 1.0) +PDIBL2_i;
    end else begin
        DIBLfactor = PDIBL1_i * exp(-tmp) + PDIBL2_i;
    end
    
     
     

    // Back gate biasing effect
    if ( WELLTYPE== `ptype) begin
        temp = DBGPW * Leff / scl;      
        if (temp>40.0) begin
            T0 = lexp(temp)/2.0;
        end else begin    
            T0 = cosh(temp) - 1.0;
        end
        T1       = KBG0PW - 0.5 * KBG1PW / T0;
        T2       = KBG2PW;
        vknee1   = VKNEE1PW;
        vknee2   = VKNEE2PW;
        bpfactor = BPFACTORPW;
    end else begin
        temp = DBGNW * Leff / scl;      
        if (temp>40.0) begin
            T0 = lexp(temp)/2.0;
        end else begin 
            T0 = cosh(temp) - 1.0;
        end
        T1       = KBG0NW - 0.5 * KBG1NW / T0;
        T2       = KBG2NW;
        vknee1   = VKNEE1NW;
        vknee2   = VKNEE2NW;
        bpfactor = BPFACTORNW;
    end

    T0  = T1 - T2;
    kvbg    = T2 + 0.5 * (T0 + sqrt(T0*T0 + 0.0001));

    // Back-gate (substrate) depletion effect
    vsubdep0    =  `q * NBG * epssi / (2.0 * cox2 * cox2);
    if (NBG!=0) begin 
        T0  = sqrt(1.0 + hypsmooth(welsign * (devsign*vbgx - vknee1),1.0e-2)/ vsubdep0) - 1.0;
    end else begin 
        T0  = 0;
    end
    vsubdep     =  vsubdep0 * T0 * T0;
    vsubdep     =  -hypmax( - vsubdep, -vknee2, 1.0e-2);

    // SCE, DIBL, RSCE, and SS degradation effects *** Ref: BSIM4 Model

    vbgxpos     = hypsmooth(vbgx,1e-3);
    phist       = 0.4 + phib + PHIN_i;
    dvth_vtroll = -DVT0_i * Theta_SCE * (vbi - phist);
    dvth_dibl   = - (ETA0_t + ETAB_i*vbgx) * Theta_DIBL * vdsx + (DVTP0_i * Theta_DITS * pow(vdsx, DVTP1_i));
    dvth_rsce   = K1RSCE_i * Theta_RSCE * sqrt(phist);
    dvth_dsc    = -DSC0 / (Leff + DSC1) * vdsx;
    T1          = csi * cox2 / (csi + cox2);
    T2          = (CDSCD_i + CBGCBGD*vbgxpos) * vdsx;
    T3          = CBGCBG0*vbgx + CBGCBG0P*vbgx*vbgx + Theta_SCE * (CDSC_i + CBGCBG_i*vbgx + CBGCBGP*vbgx*vbgx + T2);
    nVtm        = Vtm * ((cox1 + T1 + CIT_i + T3) / (cox1 + T1));
   
    // Threshold voltage shift because of body doping; Consistent with Noguchi et al., EDL 2001
    dvth_nbody  = `q * NBODY_i * TSI / cox1 * (1 - 0.5 * TSI / (TSI + epsratio * EOT2)); 
    T0          = (KT2 + KT2L / Leff) * vbgx ;
    dvth_temp   = dvth_temp0 + T0 * (TRatio - 1.0);
    dvth_all    = dvth_vtroll + dvth_dibl + dvth_rsce + dvth_dsc + dvth_nbody + dvth_temp;// + dvth_vbg;
    vgfb1eff    = vgfb1 - dvth_all + DELVTRAND; 

	// Threshold voltage operating point
    Qis 	= cox1* Vtm; //Inversion charge at threshold, drift component=diffusion component
    t1 	= 2*Nc*Vtm*`q*epssi;
    t2 	= 3*EOT2 + TSI ;
    t3 	= Qis ;
    t4 	= epssi/t2;
    xb 	= -1.2 - symmetry_factor; 
    x 		= 2*Vtm*lln(Qis/(pow(t1, 0.5))) ;      
    fx 	= t3*t3 + 2*t3*t4*(x-xb) - t1*lexp(x/Vtm) ;        		//charge implicit equation in terms of phis1
    f1x 	= 2*t3*t4 -(t1/Vtm)*lexp(x/Vtm) ;
    f2x 	=  -(t1/(Vtm*Vtm))*lexp(x/Vtm) ;            						//helley's method
    x 		=x - (2*fx*f1x)/((2*f1x*f1x)-(fx*f2x)) ;
    phit = x; //Surface potential at threshold
    T1	=csi * cox2 / (csi + cox2);
    T2 	= Qis/cox1 + deltaphi1 + phit - (T1/cox1) * (xb-phit);
    Vth 	= devsign*(T2 + dvth_all);
	
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // --------------------------------------------------------
    //   Source End Surface Potential and Charge Calculation : NEW CORE
    // --------------------------------------------------------   
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////     
    A0  = (2.0*`q*ni*TSI*TSI)/(epssi*nVtm);
    k1  = cox1/csi;
    k2  = cox2/csi; 
    xg1 = vgfb1eff/nVtm;
    xg2 = (vgfb2- dvth_all + DELVTRAND - (devsign * welsign * bpfactor * vsubdep) )/nVtm;
     
    //1. saturation potential calculation
    PHISsat=ln((2.0*`M_PI)*(2.0*`M_PI)/A0);//initial guess for saturation potential calculation
    //xg1g = connectingfx(xg1,PHISsat,0.002);//clamping of x1 for sat potential calculation only
    xg1g = xg1;
    g = ln((k1*k1*q1*q1+(2.0*`M_PI)*(2.0*`M_PI))/A0)-PHISsat;
    if (abs(g)>1.0e-10) begin
        `bsimimg_sp_phissat(surfsat,PHISsat,k1,xg1g,A0,g,dg1,dg2,dg3,PHISsat)
            if (abs(g)>1.0e-10) begin
                `bsimimg_sp_phissat(surfsat,PHISsat,k1,xg1g,A0,g,dg1,dg2,dg3,PHISsat)  
                if (abs(g)>1.0e-10) begin
                    `bsimimg_sp_phissat(surfsat,PHISsat,k1,xg1g,A0,g,dg1,dg2,dg3,PHISsat)                
                end                              
            end    
    end
    phisats = PHISsat*nVtm;
    //2. initial guess for front potential
    //factortransition = 1.0e-2;
    factortransition = 0.5*(5.0e-2-1e-2)*vbgs+1e-2;
    factortransition = connectingfx3(factortransition,1e-1,1e-5);
    factortransition = connectingfx(factortransition,1e-2,1e-5);  
    `bsimimg_sp_guess(GUESSS,TSI,epsratio,EOT1,EOT2,xg1,xg2,nVtm,PHISsat,factortransition,phifguess)
    
    phisguesss = phifguess*nVtm;
    //3. final potential calculation
    //deltanr = 0.5;
    deltanr = -0.5*vbgs+0.7;
    deltanr = connectingfx3(deltanr,0.9,1e-4);
    deltanr = connectingfx(deltanr,0.2,1e-4);
    abscri = 1.0e-7;
    flag_loop = 0;
    deltaold=100.0;
    factordelta = 1.0e-10;
    phi1 = phifguess;
    f=1.0;
    `include "potential_iteration.include"

    phifsnew = phi1*nVtm;
    phibsnew = phi2*nVtm;
    qfronts=(xg1-phi1)*cox1*nVtm;
    qbacks=(xg2-phi2)*cox2*nVtm;
    qtots=qfronts+qbacks;
    alphas = qsqrt*(nVtm*nVtm/(TSI*TSI)); 
   
    ebs = q2*cox2*nVtm/epssi;

    // -------------------------------------------------------------
    //   Drain Saturation Voltage [Reference: PSP 102.1, BSIM 4.6.0]    
    // -------------------------------------------------------------
    qis = qtots / cox1; 
    qbs = `q * NBODY_i * TSI / cox1;
    T2  = eta_mu * qis + qbs + ebs * epssi / cox1;
    T3  = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffs   = EeffFactor * T3;
        
    begin : source_mobility_calc 
        real T2, T3; 
        qb0     =  1.0e-2 / cox1;
        T2      = pow(0.5 * (1.0 + abs((qis) / qb0)), UCS_t);
        T3      = ((UA_t) + vbgs * (UC_t)) * pow(abs(Eeffs), EU_i) + (UD_t) / T2; 
        Dmobs   = 1.0 + T3; 
        Dmobs   = Dmobs / U0MULT; 
    end

`ifdef __RDSMOD__ 
    if(RDSMOD != 0) begin 
        Rdss = 0.0; 
    end else begin 
`else
    begin
`endif 
        Rdss = (RSourceGeo + RDrainGeo + (RDSWMIN_i + RDSW_i / (1.0 + PRWG_i * qis)) * WeffWRFactor) * (NF) * rdstemp;
    end
        
    Esat    = 2 * VSAT_t / u0 * Dmobs; 
    EsatL   = Esat * Leff; 
    T6      = KSATIV_i * (qtots/cox1 + 2*Vtm*KSUBIV_i); 
 
    if (Rdss == 0) begin 
        Vdsat   = EsatL * T6 / (EsatL + T6); 
    end else begin 
        WVCox   = Weff * VSAT_t * cox1; 
        T0      = WVCox * Rdss; 
        Ta      = 2 * T0; 
        Tb      = T6 + EsatL + 3*T6*T0; 
        Tc      = T6 * (EsatL + 2*T6*T0); 
        Vdsat   = (Tb - sqrt(Tb*Tb - 2*Ta*Tc)) / Ta; 
    end 
    Vdsat   = hypsmooth(Vdsat-1.0E-3 , 1.0E-5) + 1.0E-3; 
    T7      = pow(vds/Vdsat , MEXP_t); 
    T8      = pow(1.0+T7, inv_MEXP); 
    Vdseff  = vds / T8; 
    if (Vdseff > vds) Vdseff = vds;
        
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////        
    // --------------------------------------------------------
    //   Drain End Surface Potential and Charge Calculation : NEW CORE
    // -------------------------------------------------------- 
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////       

    xg1 = (vgfb1eff-Vdseff)/nVtm;
    xg2 = (vgfb2 - dvth_all + DELVTRAND- (devsign * welsign * bpfactor * vsubdep)-Vdseff)/nVtm; 
    
    //1. saturation potential calculation
    PHISsat=ln((2.0*`M_PI)*(2.0*`M_PI)/A0);//initial guess for saturation potential calculation
    //xg1g = connectingfx(xg1,PHISsat,0.002);//clamping of x1 for sat potential calculation only
    xg1g = xg1;
    g = ln((k1*k1*q1*q1+(2.0*`M_PI)*(2.0*`M_PI))/A0)-PHISsat;
    if (abs(g)>1.0e-10) begin
        `bsimimg_sp_phissat(surfsat,PHISsat,k1,xg1g,A0,g,dg1,dg2,dg3,PHISsat)
            if (abs(g)>1.0e-10) begin
                `bsimimg_sp_phissat(surfsat,PHISsat,k1,xg1g,A0,g,dg1,dg2,dg3,PHISsat)  
                if (abs(g)>1.0e-10) begin
                    `bsimimg_sp_phissat(surfsat,PHISsat,k1,xg1g,A0,g,dg1,dg2,dg3,PHISsat)                
                end                              
            end    
    end
    phisatd = PHISsat*nVtm;        
    //2. initial guess
    `bsimimg_sp_guess(GUESSD,TSI,epsratio,EOT1,EOT2,xg1,xg2,nVtm,PHISsat,factortransition,phifguess) 
    //3. final potential
    flag_loop = 0;
    deltaold=100.0;
    phi1 = phifguess; 
    phidguesss = phifguess*nVtm;
    `include "potential_iteration.include" 
       
    phifdnew = phi1*nVtm;
    phibdnew = phi2*nVtm;
    qfrontd=(xg1-phi1)*cox1*nVtm;
    qbackd=(xg2-phi2)*cox2*nVtm;
    qtotd=qfrontd+qbackd;
    alphad = qsqrt*(nVtm*nVtm/(TSI*TSI));       

    ebd = q2*cox2*nVtm/epssi;   
    // ----------------------------------------
    //   Average Potential and Charge
    // ----------------------------------------
    qid     = qtotd / cox1;
    qia     = 0.5 * (qis + qid);
    dqi     = qis - qid;
    qba     = `q * NBODY_i * TSI / cox1;
    eba     = 0.5 * (ebs + ebd);
    
    if(CHARGEWF != 0) begin       
        qia2 = 0.5 * (qis + qid) + CHARGEWF * (1.0-lexp(-T0))* 0.5 * dqi;   
    end else begin
        qia2 = 0.5 * (qis + qid);
    end

    //Multiplication factor for I-V
    beta    = u0 * cox1 * Weff / Leff;

    // -------------------------------------------------------      
    //   Mobility Degradation [Reference: BSIM4 and PSP 102.1]
    // ------------------------------------------------------
    T2      = eta_mu * qia2 + qba ;//+ eba * epssi / (cox1+;
    T3      = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));                                   // Eeff is clamped to 0 to avoid numerical problems
    Eeffm   = EeffFactor * T3;                                                      // Average electric field in the inversion layer (in the unit of MV/cm)
        
    begin : average_mobility_calc 
        real T2, T3; 
        T2    = pow(0.5 * (1.0 + abs((qia) / qb0)), UCS_t);
        T3    = (UA_t + vbgx * UC_t) * pow(abs(Eeffm), EU_i) + (UD_t + vbgx*UDB_i) / T2; 
        Dmob  = 1.0 + T3; 
        Dmob  = Dmob / U0MULT; 
        ueff  = u0 / Dmob; 
    end

    // *** Mobility Degradation for C-V ***
    Eeffm_cv    =  EeffFactor * (qba + eta_mu_cv * qia);    // in the unit of MV/cm
    T3          =  UA_t * pow(abs(Eeffm_cv), EU_i); 
    Dmob_cv     =  1.0 + T3; 
    Dmob_cv     =  Dmob_cv / U0MULT; 

    
    // -------------------------
    //    Velocity Saturation
    // ------------------------     
    Esat1   = 2.0 * VSAT1_t / ueff; 
    Esat1L  = Esat1 * Leff; 

    T0      = 0.8 + VSATB_t * vbgx;  
    Xsat    = 0.2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.01)); 
    T0      = dqi / Esat1L * Xsat; 
    Dvsat   = (1.0 + sqrt(DELTAVSAT + T0 * T0)) / (1.0 + sqrt(DELTAVSAT)); 
    Dvsat   = Dvsat + 0.5 * (PTWG_t - PTWGB_i*vbgxpos - PTWGB2_i*vbgx) * qia * dqi * dqi; 

    EsatCV  =  2.0 * VSATCV_t * Dmob_cv / u0; 
    EsatCVL =  EsatCV * LeffCV; 

    // --------------------------------------
    // Output Conductance Modules
    // -------------------------------------- 
    if(PVAG_i > 0) begin 
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL; 
    end else begin       
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end 
 
    if (Vdseff > vds) Vdseff = vds; 
    diffVds     = vds - Vdseff; 
    Vgst2Vtm    = qia + 2.0 * Vtm; 
    
    if (DIBLfactor > 0) begin 
        T1      = Vgst2Vtm; 
        T3      = T1 / (Vdsat + T1); 
        VaDIBL  = T1 / DIBLfactor * T3 * PVAGfactor; 
        Moc     = 1.0 + diffVds / VaDIBL; 
    end else begin 
        Moc = 1.0; 
    end 
 
    if(PCLM_i > 0) begin                   
        if(PCLMG < 0.0) begin 
             T1 =  1.0 / (1.0 / PCLM_i - PCLMG * qia); 
        end else begin        
             T1 = PCLM_i * (1.0 + PCLMG * qia);
        end 
        Mclm    = 1.0 + T1 * lln(1.0 + (vds - Vdseff) / T1 / (Vdsat + EsatL));
    end else begin 
        Mclm    = 1.0; 
    end 
    Moc     = Moc * Mclm;
 
        // *** Channel Length Modulation factor for C-V ***
    if(PCLMCV_i > 0) begin
        MclmCV =  1.0 + PCLMCV_i * lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL)); 
    end else begin 
        MclmCV =  1.0;
    end
    
    // ------------------------------------------------------------
    //  Lateral Non-uniform doping effect (IV-CV Vth shift) factor 
    // ------------------------------------------------------------

    if(K0_t != 0) begin
        T1          =  K0_t / (K0SI_t * qia + 2.0 * nVtm);
        Mnud        =  lexp(-T1);
    end else begin
        Mnud        =  1.0;
    end

    // ------------------------------------
    //    I-V Equation
    // ------------------------------------
    ids0            = (2.0*Vtm*(qfronts-qfrontd)-0.5*(qfrontd*qfrontd/cox1-qfronts*qfronts/cox1)+2.0*Vtm*(qbacks-qbackd)-0.5*(qbackd*qbackd/cox2-qbacks*qbacks/cox2));//+0.5*TSI*epssi*(alphas-alphad);

    ids0_ov_dqi     = 0.5 * (qis + qid) + Vtm;

    // -----------------------------
    //   S/D series resistance
    // -----------------------------
    begin : rdsblock 
        real T1, T4; 

`ifdef __RDSMOD__ 
        real vgs_eff, vgd_eff; 
        real T2, T3; 
        if(RDSMOD != 0) begin 
            Rdsi        = 0.0; 
            Dr          = 1.0; 
            T2          = vgs_noswap - vfbsd; 
            T3          = sqrt(T2 * T2 + 1.0e-4); 
            vgs_eff     = 0.5 * (T2 + T3); 
            T4          = 1.0 + PRWG_i * vgs_eff; 
            T1          = 1.0 / T4; 
            T1          = T1 - 0.5 * vbgs_noswap * PRWB_i; 
            T0          = 0.5 * (T1 + sqrt(T1 * T1 + 0.01)); 
            Rsource     = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T0) * WeffWRFactor); 
            T2          = vgd_noswap - vfbsd; 
            T3          = sqrt(T2 * T2 + 1.0e-4); 
            vgd_eff     = 0.5 * (T2 + T3); 
            T4          = 1.0 + PRWG_i * vgd_eff; 
            T1          = 1.0 / T4; 
            T1          = T1 - 0.5 * vbgd_noswap * PRWB_i; 
            T0          = 0.5 * (T1 + sqrt(T1 * T1 + 0.01)); 
            Rdrain      = rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T0) * WeffWRFactor); 
        end else begin 
`endif 
            T4          = 1.0 + PRWG_i * qia; 
            T1          = 1.0 / T4; 
            T1          = T1 - 0.5 * (vbgd + vbgs) * PRWB_i; 
    
            T0          = 0.5 * (T1 + sqrt(T1 * T1 + 0.01)); 
            Rdsi        = rdstemp * ( (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor); 
            Dr          = 1.0 + (NF) * beta * ids0_ov_dqi / (Dmob * Dvsat) * Rdsi; 
`ifdef __RDSMOD__ 
            Rdrain      = RDrainGeo ;
            Rsource     = RSourceGeo ;
        end 
`endif 
    end // End of rdsblock


    ids = (u0 * Weff / Leff) * ids0 * Moc * Mnud / (Dmob * Dvsat * Dr);//TODO: check beta in other places and find out why it is used


    // ------------------------------------
    //    C-V Equation
    // ------------------------------------
    qfg = (qfrontd+qfronts)/2.0;
    qd  = (1.0/6.0)*(qtots+2.0*qtotd);
    qs  = (1.0/6.0)*(2.0*qtots+qtotd);
    qbg = (qbackd+qbacks)/2.0;
    // True Charge
    // Quantum Mechanical Effects
    if(QMTCENCV_i > 0.0) begin          
        T4      =  (qia + ETAQM * qba) / QM0;   
        T5      =  1.0 + pow(T4 , PQM);     
        Tcen0   =  TSI;             
        Tcen    =  Tcen0 / T5;          
        coxeff  =  3.9 * `EPS0 / (IMGTOXP * 3.9 / EPSROX1 + Tcen * QMTCENCV_i / epsratio);          
    end else begin 
        coxeff  = cox1P;
    end                            
      

    T0      = WeffCV * LeffCV / MclmCV;//coxeff removed         
    qfg     = qfg * T0;
    qd      = -qd * T0;
    qbg     = qbg * T0;
    qs      = -qs * T0;

    // ------------------------------------
    // Parasitic Capacitances
    // ------------------------------------
    // Note: the back gate capacitance is assumed to be negligible due to the thick oxide.
    qfgs_ov     = WeffCV * LOVS_i * cox1 *  V(`GateEdgeNode, `IntrinsicSource);
    qfgd_ov     = WeffCV * LOVD_i * cox1 *  V(`GateEdgeNode, `IntrinsicDrain);

    // Bias-dependent overlap capacitances
    T0              = vgs_ov_noswap - vfbsd + `DELTA_1;
    vfgs_overlap    = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    qfgs_ov         = qfgs_ov + WeffCV * CGSL * (vgs_ov_noswap - vfbsd - vfgs_overlap - 0.5 * CKAPPAS * (sqrt(1.0 - 4.0 * vfgs_overlap / CKAPPAS)- 1.0)) * devsign;
    T0              = vgd_ov_noswap - vfbsd + `DELTA_1;
    vfgd_overlap    = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    qfgd_ov         = qfgd_ov + WeffCV * CGDL * (vgd_ov_noswap - vfbsd - vfgd_overlap - 0.5 * CKAPPAD * (sqrt(1.0 - 4.0 * vfgd_overlap / CKAPPAD)- 1.0)) * devsign;

    // Outer fringe capacitances
    qfgs_of     = WeffCV * CFS_i * V(`GateEdgeNode, `IntrinsicSource);
    qfgd_of     = WeffCV * CFD_i * V(`GateEdgeNode, `IntrinsicDrain);

    qfgs_parasitic = qfgs_ov + qfgs_of ;
    qfgd_parasitic = qfgd_ov + qfgd_of ;

    
    Qsbg        = csbox * V(`IntrinsicSource, bg)*devsign;
    Qdbg        = cdbox * V(`IntrinsicDrain, bg)*devsign;

    // ------------------------------------ 
    //   Impact Ionization Current 
    // ------------------------------------
    T0 = (ALPHA0_i + ALPHA1_i * Leff) / Leff;
    if ((T0 <= 0.0) || (BETA0_t <= 0.0)) begin
        Iii = 0.0;
    end else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
        T1  = - BETA0_t / diffVds;
        Iii = T0 * diffVds * ids * lexp(T1);
    end else begin
        Iii = T0 * diffVds * ids * `MIN_EXPL;
    end

    // ------------------------------------ 
    //     Gate Current
    // ------------------------------------ 

    //---------------modification to Gate current in sync with BSIMCMG105.04 code       
    // *** Gate Current ***
    // Ref: BSIM4 Model
    igbinv  =  0.0;
    igbacc  =  0.0;
    igcs    =  0.0;
    igcd    =  0.0;
    igs     =  0.0;
    igd     =  0.0;
        
    // Igb
    if (IGBMOD != 0) begin
        //Igbinv
        T1      =  (qia - EIGBINV_i) / NIGBINV_i / Vtm;
        Vaux_Igbinv =  NIGBINV_i * Vtm * lln(1 + lexp(T1));
        T2      =  AIGBINV_i - BIGBINV_i * qia;
        T3      =  1 + CIGBINV_i * qia;
        T4      =  -9.82222e11 * TOXP * T2 * T3;
        T5      =  lexp(T4);
        T6      =  3.75956e-7;
        igbinv  =  Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbinv * T5;
        igbinv  =  igbinv * igtemp;
        
        //Igbacc
        vfbzb   =  deltaphi1  - phib;//-Eg/2.0
        T0      =  vfbzb - vgbg;
        T1      =  T0 / NIGBACC_i / Vtm;
        Vaux_Igbacc =  NIGBACC_i * Vtm * lln(1 + lexp(T1));
        
        if(vfbzb <=0) begin
            Voxacc  =  0.5 * (T0 - 0.02 + sqrt((T0 - 0.02)*(T0 - 0.02) - 0.08 * vfbzb));
        end else begin
            Voxacc  =  0.5 * (T0 - 0.02 + sqrt((T0 - 0.02)*(T0 - 0.02) + 0.08 * vfbzb));
        end
            
        T2      =  AIGBACC_i - BIGBACC_i * Voxacc;
        T3      =  1 + CIGBACC_i * Voxacc;
        T4      =  -7.45669e11 * TOXP * T2 * T3;
        T5      =  lexp(T4);
        T6      =  4.97232e-7;
        igbacc  =  Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbacc * T5;
        igbacc  =  igbacc * igtemp;
            
    end

    // Gate to Body Tunneling current empirical partition       
    T0  =  tanh(0.6*vds_noswap/Vtm) ;
    wf      = 0.5 + 0.5 * T0;
    wr      = 1.0 - wf;
    igbs    =  (igbinv + igbacc) * wf;
    igbd    =  (igbinv + igbacc) * wr;
        

    if(IGCMOD != 0) begin
        // Igcinv
        T1      =  AIGC_i - BIGC_i * qia;
        T2      =  1.0 + CIGC_i * qia;
        T3      =  -Bechvb * TOXP * T1 * T2;
        T4      =  qia * lexp(T3);
        T5      =  (vgbg + 0.5 *vdsx + 0.5*(vbgs_noswap+ vbgd_noswap));
        igc0    =  Weff * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;
        
        // Gate-current partitioning
        Vdseffx =  sqrt(Vdseff*Vdseff + 0.01) - 0.1;
        T1      =  PIGCD_i * Vdseffx;
        T1_exp  =  lexp(-T1);
        T3      =  T1 + T1_exp -1.0 + 1.0E-4;
        T4      =  1.0 - (T1 + 1.0) * T1_exp + 1.0E-4;
        T5      =  T1 * T1 + 2.0E-4;
        igcd    =  igc0 * T4 / T5;
        igcs    =  igc0 * T3 / T5;
        
        // Igs
        T0      =  vgs_noswap;
        vfgs_eff=  sqrt(T0 * T0 + 1.0e-4);
        T1      =  AIGS_i - BIGS_i * vfgs_eff;
        T2      =  1.0 + CIGS_i * vfgs_eff;
        T3      =  -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4      =  lexp(T3);
        
        if(sigvds > 0) begin 
           igs  =  igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end else begin       
           igd  =  igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end
        
        // Igd
        T0      =  vgd_noswap;
        vfgd_eff=  sqrt(T0 * T0 + 1.0e-4);
        T1      =  AIGD_i - BIGD_i * vfgd_eff;
        T2      =  1.0 + CIGD_i * vfgd_eff;
        T3      =  -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4      =  lexp(T3);

        if(sigvds > 0) begin 
           igd  =  igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end else begin       
           igs  =  igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end
        
    end


    // ---------------------------
    //    GIDL/GISL current 
    // ---------------------------
    igisl = 0.0;
    igidl = 0.0;
    if (GIDLMOD != 0) begin
        T0 =  epsratio * EOT1;

        // ** GIDL **
        if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
            T6 =  0.0;
        end else begin
            T1 =  (- vgd_noswap - EGIDL_i + vfbsd) / T0;
            T1 =  hypsmooth(T1, 1.0E-2);
            T2 =  BGIDL_t / (T1 + 1.0E-3);
            T3 =  lexp(PGIDL_i * lln(T1));
            T6 =  AGIDL_i * Weff * T3 * lexp(-T2) * vds_noswap;
        end
        if(sigvds > 0.0) begin 
            igidl  =  T6;
        end else begin         
            igisl  =  T6;
        end
            
        // ** GISL **
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
            T6 =  0.0;
        end else begin
            T1 =  (- vgs_noswap - EGISL_i + vfbsd) / T0;
            T1 =  hypsmooth(T1, 1.0E-2);
            T2 =  BGISL_t / (T1 + 1.0E-3);
            T3 =  lexp(PGISL_i * lln(T1));
            T6 =  AGISL_i * Weff * T3 * lexp(-T2) * (- vds_noswap);
        end
        if(sigvds > 0.0) begin 
            igisl  =  T6;
        end else begin         
            igidl  =  T6;
        end
    end
        
    //*****************************************************************
    //***   Noise Models
    //*****************************************************************
    Esatnoi    =  2.0 * VSAT_t / ueff;                          // Thermal noise and flicker noise
                
    // ** Flicker Noise **
    // Ref: BSIM4 Model; K. K. Hung et al., TED 1990 
    if(NOIA > 0 || NOIB > 0 || NOIC > 0) begin
        Leffnoi     =  Leff - 2.0 * LINTNOI_i;
        Leffnoisq   =  Leffnoi * Leffnoi;
        if(EM <= 0.0) begin 
            DelClm =  0.0;
        end else begin
            T0  =  (diffVds / litl + EM) / Esatnoi;
            DelClm  =  litl * lln(T0);
            if (DelClm < 0.0) begin DelClm =  0.0;
            end
        end

        T1  =  `q * `q * `q * Vtm * abs(ids) * ueff;
        T2  =  1.0e10 * coxeff * Leffnoisq;
        N0  =  coxeff * qis / `q;
        Nl  =  coxeff * qid / `q;

        Nstar   =  Vtm / `q * (coxeff + CIT_i);
        T3  =  NOIA * lln((N0 + Nstar) / (Nl + Nstar));
        T4  =  NOIB * (N0 - Nl);
        T5  =  0.5 * NOIC * (N0 * N0 - Nl * Nl);
        T6  =  `q * Vtm * ids * ids;

        T7  =  1.0e10 * Leffnoisq * Weff * NF;  
        T8  =  NOIA + NOIB * Nl + NOIC * Nl * Nl;
        T9  =  (Nl + Nstar) * (Nl + Nstar);
        Ssi =  T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;
        
        T10 =  NOIA * `q * Vtm;
        T11 =  Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
        Swi =  T10 / T11 * ids * ids;
            
        T1  =  Swi + Ssi;
        if (T1 > 0.0) begin FNPowerAt1Hz    =  (Ssi * Swi) / T1;
        end else      begin FNPowerAt1Hz    =  0.0;
        end
    end else begin
        FNPowerAt1Hz =  0.0;
    end
    
    //Intrinsic Charges
    qfgi    = NF * qfg;             
    qbgi    = NF * qbg;
    // qsi and qdi are defined below

    if (sigvds > 0) begin
        qsi = NF * qs; 
        qdi = NF * qd;
        qs  = NF * (qs-qfgs_parasitic +Qsbg);
        qd  = NF * (qd-qfgd_parasitic +Qdbg);
    end else begin
        qsi = NF * qd; 
        qdi = NF * qs; 
        T0  = NF * (qd-qfgs_parasitic +Qsbg);
        qd  = NF * (qs-qfgd_parasitic +Qdbg);
        qs  = T0 ;
    end

    qfg     = NF * (qfg+qfgs_parasitic+qfgd_parasitic); 
    qbg     = NF * (qbg-Qsbg-Qdbg);
    
    
    qfgs_parasitic  = NF * qfgs_parasitic;
    qfgd_parasitic  = NF * qfgd_parasitic;
    Qsbg        = NF * Qsbg;
    Qdbg        = NF * Qdbg;

    // ** Thermal Noise **
    // Charge-based model (BSIM4 - TNOIMOD=0)
    qinv    =  -(qs+qd);
    T0      =  ueff * qinv;     
    T1      =  T0 * Rdsi + Leff * Leff;
    Gtnoi   =  (T0 / T1) * NTNOI_i;
    Nt      =  4.0 * Vtm * `q; 
    sid     =  Nt * Gtnoi;

    
    // End of Bias dependent calculation

    //*****************************************************************
    // Loading variables 
    ids     = NF * ids;
    igidl   = NF * igidl;
    igisl   = NF * igisl;
    igcd    = NF * igcd;
    igcs    = NF * igcs;
    igs     = NF * igs;
    igd     = NF * igd;

    if (sigvds > 0) begin
        I(`IntrinsicDrain, `IntrinsicSource)    <+ devsign * ids + (GDSMIN * V(`IntrinsicDrain,`IntrinsicSource));
        I(`IntrinsicDrain, `IntrinsicSource)    <+ devsign * (igidl + Iii);
        I(`IntrinsicSource, `IntrinsicDrain)    <+ devsign * igisl;
        I(`IntrinsicGate, `IntrinsicSource)     <+ devsign * (igcs + igs + igbs);
        I(`IntrinsicGate, `IntrinsicDrain)      <+ devsign * (igcd + igd + igbd);

    end else begin
        I(`IntrinsicSource, `IntrinsicDrain)    <+ devsign * ids + (GDSMIN * V(`IntrinsicSource,`IntrinsicDrain));
        I(`IntrinsicSource, `IntrinsicDrain)    <+ devsign * (igidl + Iii);
        I(`IntrinsicDrain, `IntrinsicSource)    <+ devsign * igisl;
        I(`IntrinsicGate, `IntrinsicDrain)      <+ devsign * (igcs + igs + igbs);
        I(`IntrinsicGate, `IntrinsicSource)     <+ devsign * (igcd + igd + igbd);

    end

    I(`IntrinsicDrain, `IntrinsicSource)    <+ devsign * ddt(qdi);
    I(`IntrinsicGate, `IntrinsicSource)     <+ devsign * ddt(qfgi);
    I(bg, `IntrinsicSource)                 <+ devsign * ddt(qbgi);
    I(`GateEdgeNode, `IntrinsicSource)      <+ ddt(qfgs_parasitic);
    I(`GateEdgeNode, `IntrinsicDrain)       <+ ddt(qfgd_parasitic);

    I(`IntrinsicSource, bg)         <+ ddt(Qsbg);
    I(`IntrinsicDrain, bg)          <+ ddt(Qdbg);


`ifdef __RDSMOD__ 
    if(Rdrain > 0.001) begin
        gdpr = 1.0/Rdrain ;
        I(d, `IntrinsicDrain) <+ white_noise(Nt*gdpr, "Rd");
    end else begin 
        V(d, `IntrinsicDrain) <+ 0.0;
    end
    if(Rsource > 0.001) begin
        gspr = 1.0/Rsource ;
        I(s, `IntrinsicSource) <+ white_noise(Nt*gspr, "Rs");
    end else begin
        V(s, `IntrinsicSource) <+ 0.0;
    end      
`endif

`ifdef __RGATEMOD__
    if (RGATEMOD == 0) begin
        V(fg, gi) <+ 0;
    end else begin : rgate
        real Ggate, Gnoise;
        Ggate = Grgeltd;
        Gnoise  = Grgeltd;  
        I(fg, gi) <+ V(fg, gi) * Ggate;
        I(fg, gi) <+ white_noise( Nt*Gnoise, "Rg");
    end
`endif



    // Flicker Noise
    I(`IntrinsicDrain,`IntrinsicSource) <+  flicker_noise(FNPowerAt1Hz, EF, "flicker");
    
    // Channel thermal noise and induced gate noise stamping
    // Implementation of correlated noise follows C. C. McAndrew, WCM 2005
    I(`IntrinsicDrain, `IntrinsicSource) <+ white_noise(sid, "Id");

    // Gate current shot noise
    if(IGCMOD != 0) begin
        if(sigvds > 0) begin
            I(`IntrinsicGate, `IntrinsicSource)     <+  white_noise(2 * `q * abs(igcs + igs), "Igs");
            I(`IntrinsicGate, `IntrinsicDrain)      <+  white_noise(2 * `q * abs(igcd + igd), "Igd");
        end else begin
            I(`IntrinsicGate, `IntrinsicDrain)      <+  white_noise(2 * `q * abs(igcs + igs), "Igd");
            I(`IntrinsicGate, `IntrinsicSource)     <+  white_noise(2 * `q * abs(igcd + igd), "Igs");
         
        end
    end
    if(IGBMOD != 0) begin
        I(`IntrinsicGate, `IntrinsicSource)   <+  white_noise(2 * `q * abs(igbs), "Igb");
        I(`IntrinsicGate, `IntrinsicDrain)    <+  white_noise(2 * `q * abs(igbd), "Igb");
    end


    // Stamping external S/D Resistance
`ifdef __RDSMOD__ 
    if(RDSMOD != 0) begin 
        if(Rdrain > 0.001) begin 
            I(d, `IntrinsicDrain) <+ V(d, `IntrinsicDrain) / Rdrain; 
        end else begin 
            V(d, `IntrinsicDrain) <+ 0.0;
        end 
        if(Rsource > 0.001) begin 
            I(s, `IntrinsicSource) <+ V(s, `IntrinsicSource) / Rsource; 
        end else begin 
            V(s, `IntrinsicSource) <+ 0.0;
        end 
    end else begin 
        V(d, `IntrinsicDrain) <+ 0; 
        V(s, `IntrinsicSource) <+ 0; 
    end 
`endif  


    // Self Heating
`ifdef __SHMOD__
    if (RTH0 > 0) begin
        Pwr(ith_branch) <+ -devsign * sigvds * V(`IntrinsicDrain, `IntrinsicSource) * ids;
    end
    Pwr(rth_branch)     <+ Temp(rth_branch) * gth;
    Pwr(rth_branch)     <+ ddt(Temp(rth_branch) * cth); 
`endif

    // Operation Point Info
    IDS     = devsign * sigvds * ids;
	VDSSAT =  Vdsat;                              			// Drain-Source saturation Voltage
  	VTH = Vth;														// Threshold Volatge
	// Conductances
    GM     =  ddx(IDS,V(`IntrinsicGate));         // Transconductance
    GDS    =  ddx(IDS,V(`IntrinsicDrain));       // Output conductance
	GMBS   =  ddx(IDS,V(bg));                  		// Body transconductance
    /*Intrinsic Charges*/
    QFGI    = devsign * qfgi;
    QBGI    = devsign * qbgi;
    QDI     = devsign * qdi;
    QSI     = devsign * qsi;
    /*Total Charges*/
    QFG     = devsign * qfg;
    QBG     = devsign * qbg;
    QD  = devsign * qd;
    QS  = devsign * qs;
    //Intrinsic Capacitances
    CFGDI   = -ddx(QFGI, V(`IntrinsicDrain));
    CFGFGI  = ddx(QFGI, V(`IntrinsicGate));
    CFGSI   = -ddx(QFGI, V(`IntrinsicSource));
    CSFGI   = -ddx(QSI, V(`IntrinsicGate));
    CFGBGI  = -ddx(QFGI, V(bg));
    CBGDI   = -ddx(QBGI, V(`IntrinsicDrain));
    CBGFGI  = -ddx(QBGI, V(`IntrinsicGate));
    CBGSI   = -ddx(QBGI, V(`IntrinsicSource));
    CSBGI   = -ddx(QSI,V(bg));
    CBGBGI  = ddx(QBGI, V(bg));
    CDDI    = ddx(QDI, V(`IntrinsicDrain));
    CDFGI   = -ddx(QDI, V(`IntrinsicGate));
    CDSI    = -ddx(QDI, V(`IntrinsicSource));
    CDBGI   = -ddx(QDI, V(bg));
    //Total Capacitances
    CFGD    = -ddx(QFG, V(`IntrinsicDrain));
    CFGFG   = ddx(QFG, V(`IntrinsicGate));
    CFGS    = -ddx(QFG, V(`IntrinsicSource));
    CSFG    = -ddx(QS, V(`IntrinsicGate));
    CFGBG   = -ddx(QFG, V(bg));
    CBGD    = -ddx(QBG, V(`IntrinsicDrain));
    CBGFG   = -ddx(QBG, V(`IntrinsicGate));
    CBGS    = -ddx(QBG, V(`IntrinsicSource));
    CSBG    = -ddx(QS,V(bg));
    CBGBG   = ddx(QBG, V(bg));
    CDD     = ddx(QD, V(`IntrinsicDrain));
    CDFG    = -ddx(QD, V(`IntrinsicGate));
    CDS     = -ddx(QD, V(`IntrinsicSource));
    CDBG    = -ddx(QD, V(bg));
end 
//================================================
// analog block ends   
//================================================
